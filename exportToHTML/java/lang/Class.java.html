<html>
<head>
<title>Class.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s4 { color: rgb(128,128,128); font-style: italic; }
.s5 { color: rgb(0,0,255); }
.s6 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
Class.java</FONT>
</center></TD></TR></TABLE>
<pre>

<span class="s0">/* 
 * Copyright (c) 1994, 2014, Oracle and/or its affiliates. All rights reserved. 
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */</span><span class="s1"> 
 
</span><span class="s2">package </span><span class="s1">java.lang; 
 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.AnnotatedElement; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Array; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.GenericArrayType; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.GenericDeclaration; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Member; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Field; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Executable; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Method; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Constructor; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Modifier; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Type; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.TypeVariable; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.InvocationTargetException; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.AnnotatedType; 
</span><span class="s2">import </span><span class="s1">java.lang.ref.SoftReference; 
</span><span class="s2">import </span><span class="s1">java.io.InputStream; 
</span><span class="s2">import </span><span class="s1">java.io.ObjectStreamField; 
</span><span class="s2">import </span><span class="s1">java.security.AccessController; 
</span><span class="s2">import </span><span class="s1">java.security.PrivilegedAction; 
</span><span class="s2">import </span><span class="s1">java.util.ArrayList; 
</span><span class="s2">import </span><span class="s1">java.util.Arrays; 
</span><span class="s2">import </span><span class="s1">java.util.Collection; 
</span><span class="s2">import </span><span class="s1">java.util.HashSet; 
</span><span class="s2">import </span><span class="s1">java.util.LinkedHashMap; 
</span><span class="s2">import </span><span class="s1">java.util.List; 
</span><span class="s2">import </span><span class="s1">java.util.Set; 
</span><span class="s2">import </span><span class="s1">java.util.Map; 
</span><span class="s2">import </span><span class="s1">java.util.HashMap; 
</span><span class="s2">import </span><span class="s1">java.util.Objects; 
</span><span class="s2">import </span><span class="s1">sun.misc.Unsafe; 
</span><span class="s2">import </span><span class="s1">sun.reflect.CallerSensitive; 
</span><span class="s2">import </span><span class="s1">sun.reflect.ConstantPool; 
</span><span class="s2">import </span><span class="s1">sun.reflect.Reflection; 
</span><span class="s2">import </span><span class="s1">sun.reflect.ReflectionFactory; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.factory.CoreReflectionFactory; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.factory.GenericsFactory; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.repository.ClassRepository; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.repository.MethodRepository; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.repository.ConstructorRepository; 
</span><span class="s2">import </span><span class="s1">sun.reflect.generics.scope.ClassScope; 
</span><span class="s2">import </span><span class="s1">sun.security.util.SecurityConstants; 
</span><span class="s2">import </span><span class="s1">java.lang.annotation.Annotation; 
</span><span class="s2">import </span><span class="s1">java.lang.reflect.Proxy; 
</span><span class="s2">import </span><span class="s1">sun.reflect.annotation.*; 
</span><span class="s2">import </span><span class="s1">sun.reflect.misc.ReflectUtil; 
 
</span><span class="s0">/** 
 * Instances of the class {</span><span class="s3">@code </span><span class="s0">Class} represent classes and 
 * interfaces in a running Java application.  An enum is a kind of 
 * class and an annotation is a kind of interface.  Every array also 
 * belongs to a class that is reflected as a {</span><span class="s3">@code </span><span class="s0">Class} object 
 * that is shared by all arrays with the same element type and number 
 * of dimensions.  The primitive Java types ({</span><span class="s3">@code </span><span class="s0">boolean}, 
 * {</span><span class="s3">@code </span><span class="s0">byte}, {</span><span class="s3">@code </span><span class="s0">char}, {</span><span class="s3">@code </span><span class="s0">short}, 
 * {</span><span class="s3">@code </span><span class="s0">int}, {</span><span class="s3">@code </span><span class="s0">long}, {</span><span class="s3">@code </span><span class="s0">float}, and 
 * {</span><span class="s3">@code </span><span class="s0">double}), and the keyword {</span><span class="s3">@code </span><span class="s0">void} are also 
 * represented as {</span><span class="s3">@code </span><span class="s0">Class} objects. 
 * 
 * </span><span class="s4">&lt;p&gt; </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">Class} has no public constructor. Instead {</span><span class="s3">@code </span><span class="s0">Class} 
 * objects are constructed automatically by the Java Virtual Machine as classes 
 * are loaded and by calls to the {</span><span class="s3">@code </span><span class="s0">defineClass} method in the class 
 * loader. 
 * 
 * </span><span class="s4">&lt;p&gt; </span><span class="s0">The following example uses a {</span><span class="s3">@code </span><span class="s0">Class} object to print the 
 * class name of an object: 
 * 
 * </span><span class="s4">&lt;blockquote&gt;&lt;pre&gt;</span><span class="s0"> 
 *     void printClassName(Object obj) { 
 *         System.out.println(&quot;The class of &quot; + obj + 
 *                            &quot; is &quot; + obj.getClass().getName()); 
 *     } 
 * </span><span class="s4">&lt;/pre&gt;&lt;/blockquote&gt;</span><span class="s0"> 
 * 
 * </span><span class="s4">&lt;p&gt; </span><span class="s0">It is also possible to get the {</span><span class="s3">@code </span><span class="s0">Class} object for a named 
 * type (or for void) using a class literal.  See Section 15.8.2 of 
 * </span><span class="s4">&lt;cite&gt;</span><span class="s0">The Java</span><span class="s1">&amp;trade; </span><span class="s0">Language Specification</span><span class="s4">&lt;/cite&gt;</span><span class="s0">. 
 * For example: 
 * 
 * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
 *     {</span><span class="s3">@code </span><span class="s0">System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());} 
 * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
 * 
 * </span><span class="s3">@param </span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; </span><span class="s0">the type of the class modeled by this {</span><span class="s3">@code </span><span class="s0">Class} 
 * object.  For example, the type of {</span><span class="s3">@code </span><span class="s0">String.class} is {</span><span class="s3">@code</span><span class="s0"> 
 * Class</span><span class="s4">&lt;String&gt;</span><span class="s0">}.  Use {</span><span class="s3">@code </span><span class="s0">Class</span><span class="s1">&lt;?&gt;</span><span class="s0">} if the class being modeled is 
 * unknown. 
 * 
 * </span><span class="s3">@author  </span><span class="s0">unascribed 
 * </span><span class="s3">@see     </span><span class="s0">java.lang.ClassLoader#defineClass(byte[], int, int) 
 * </span><span class="s3">@since   </span><span class="s0">JDK1.0 
 */</span><span class="s1"> 
</span><span class="s2">public final class </span><span class="s1">Class&lt;T&gt; </span><span class="s2">implements </span><span class="s1">java.io.Serializable, 
                              GenericDeclaration, 
                              Type, 
                              AnnotatedElement { 
    </span><span class="s2">private static final int </span><span class="s1">ANNOTATION= </span><span class="s5">0x00002000</span><span class="s1">; 
    </span><span class="s2">private static final int </span><span class="s1">ENUM      = </span><span class="s5">0x00004000</span><span class="s1">; 
    </span><span class="s2">private static final int </span><span class="s1">SYNTHETIC = </span><span class="s5">0x00001000</span><span class="s1">; 
 
    </span><span class="s2">private static native void </span><span class="s1">registerNatives(); 
    </span><span class="s2">static </span><span class="s1">{ 
        registerNatives(); 
    } 
 
    </span><span class="s0">/* 
     * Private constructor. Only the Java Virtual Machine creates Class objects. 
     * This constructor is not used and prevents the default constructor being 
     * generated. 
     */</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Class(ClassLoader loader) { 
        </span><span class="s0">// Initialize final field for classLoader.  The initialization value of non-null</span><span class="s1"> 
        </span><span class="s0">// prevents future JIT optimizations from assuming this final field is null.</span><span class="s1"> 
        classLoader = loader; 
    } 
 
    </span><span class="s0">/** 
     * Converts the object to a string. The string representation is the 
     * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the 
     * fully qualified name of the class in the format returned by 
     * {</span><span class="s3">@code </span><span class="s0">getName}.  If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a 
     * primitive type, this method returns the name of the primitive type.  If 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object represents void this method returns 
     * &quot;void&quot;. 
     * 
     * </span><span class="s3">@return </span><span class="s0">a string representation of this class object. 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String toString() { 
        </span><span class="s2">return </span><span class="s1">(isInterface() ? </span><span class="s6">&quot;interface &quot; </span><span class="s1">: (isPrimitive() ? </span><span class="s6">&quot;&quot; </span><span class="s1">: </span><span class="s6">&quot;class &quot;</span><span class="s1">)) 
            + getName(); 
    } 
 
    </span><span class="s0">/** 
     * Returns a string describing this {</span><span class="s3">@code </span><span class="s0">Class}, including 
     * information about modifiers and type parameters. 
     * 
     * The string is formatted as a list of type modifiers, if any, 
     * followed by the kind of type (empty string for primitive types 
     * and {</span><span class="s3">@code </span><span class="s0">class}, {</span><span class="s3">@code </span><span class="s0">enum}, {</span><span class="s3">@code </span><span class="s0">interface}, or 
     * </span><span class="s4">&lt;code&gt;&amp;#64;&lt;/code&gt;</span><span class="s0">{</span><span class="s3">@code </span><span class="s0">interface}, as appropriate), followed 
     * by the type's name, followed by an angle-bracketed 
     * comma-separated list of the type's type parameters, if any. 
     * 
     * A space is used to separate modifiers from one another and to 
     * separate any modifiers from the kind of type. The modifiers 
     * occur in canonical order. If there are no type parameters, the 
     * type parameter list is elided. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">Note that since information about the runtime representation 
     * of a type is being generated, modifiers not present on the 
     * originating source code or illegal on the originating source 
     * code may be present. 
     * 
     * </span><span class="s3">@return </span><span class="s0">a string describing this {</span><span class="s3">@code </span><span class="s0">Class}, including 
     * information about modifiers and type parameters 
     * 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String toGenericString() { 
        </span><span class="s2">if </span><span class="s1">(isPrimitive()) { 
            </span><span class="s2">return </span><span class="s1">toString(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            StringBuilder sb = </span><span class="s2">new </span><span class="s1">StringBuilder(); 
 
            </span><span class="s0">// Class modifiers are a superset of interface modifiers</span><span class="s1"> 
            </span><span class="s2">int </span><span class="s1">modifiers = getModifiers() &amp; Modifier.classModifiers(); 
            </span><span class="s2">if </span><span class="s1">(modifiers != </span><span class="s5">0</span><span class="s1">) { 
                sb.append(Modifier.toString(modifiers)); 
                sb.append(</span><span class="s6">' '</span><span class="s1">); 
            } 
 
            </span><span class="s2">if </span><span class="s1">(isAnnotation()) { 
                sb.append(</span><span class="s6">'@'</span><span class="s1">); 
            } 
            </span><span class="s2">if </span><span class="s1">(isInterface()) { </span><span class="s0">// Note: all annotation types are interfaces</span><span class="s1"> 
                sb.append(</span><span class="s6">&quot;interface&quot;</span><span class="s1">); 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">if </span><span class="s1">(isEnum()) 
                    sb.append(</span><span class="s6">&quot;enum&quot;</span><span class="s1">); 
                </span><span class="s2">else</span><span class="s1"> 
                    sb.append(</span><span class="s6">&quot;class&quot;</span><span class="s1">); 
            } 
            sb.append(</span><span class="s6">' '</span><span class="s1">); 
            sb.append(getName()); 
 
            TypeVariable&lt;?&gt;[] typeparms = getTypeParameters(); 
            </span><span class="s2">if </span><span class="s1">(typeparms.length &gt; </span><span class="s5">0</span><span class="s1">) { 
                </span><span class="s2">boolean </span><span class="s1">first = </span><span class="s2">true</span><span class="s1">; 
                sb.append(</span><span class="s6">'&lt;'</span><span class="s1">); 
                </span><span class="s2">for</span><span class="s1">(TypeVariable&lt;?&gt; typeparm: typeparms) { 
                    </span><span class="s2">if </span><span class="s1">(!first) 
                        sb.append(</span><span class="s6">','</span><span class="s1">); 
                    sb.append(typeparm.getTypeName()); 
                    first = </span><span class="s2">false</span><span class="s1">; 
                } 
                sb.append(</span><span class="s6">'&gt;'</span><span class="s1">); 
            } 
 
            </span><span class="s2">return </span><span class="s1">sb.toString(); 
        } 
    } 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Class} object associated with the class or 
     * interface with the given string name.  Invoking this method is 
     * equivalent to: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *  {</span><span class="s3">@code </span><span class="s0">Class.forName(className, true, currentLoader)} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * where {</span><span class="s3">@code </span><span class="s0">currentLoader} denotes the defining class loader of 
     * the current class. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">For example, the following code fragment returns the 
     * runtime {</span><span class="s3">@code </span><span class="s0">Class} descriptor for the class named 
     * {</span><span class="s3">@code </span><span class="s0">java.lang.Thread}: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *   {</span><span class="s3">@code </span><span class="s0">Class t = Class.forName(&quot;java.lang.Thread&quot;)} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0"> 
     * A call to {</span><span class="s3">@code </span><span class="s0">forName(&quot;X&quot;)} causes the class named 
     * {</span><span class="s3">@code </span><span class="s0">X} to be initialized. 
     * 
     * </span><span class="s3">@param      </span><span class="s0">className   the fully qualified name of the desired class. 
     * </span><span class="s3">@return     </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Class} object for the class with the 
     *             specified name. 
     * </span><span class="s3">@exception </span><span class="s0">LinkageError if the linkage fails 
     * </span><span class="s3">@exception </span><span class="s0">ExceptionInInitializerError if the initialization provoked 
     *            by this method fails 
     * </span><span class="s3">@exception </span><span class="s0">ClassNotFoundException if the class cannot be located 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public static </span><span class="s1">Class&lt;?&gt; forName(String className) 
                </span><span class="s2">throws </span><span class="s1">ClassNotFoundException { 
        Class&lt;?&gt; caller = Reflection.getCallerClass(); 
        </span><span class="s2">return </span><span class="s1">forName0(className, </span><span class="s2">true</span><span class="s1">, ClassLoader.getClassLoader(caller), caller); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Class} object associated with the class or 
     * interface with the given string name, using the given class loader. 
     * Given the fully qualified name for a class or interface (in the same 
     * format returned by {</span><span class="s3">@code </span><span class="s0">getName}) this method attempts to 
     * locate, load, and link the class or interface.  The specified class 
     * loader is used to load the class or interface.  If the parameter 
     * {</span><span class="s3">@code </span><span class="s0">loader} is null, the class is loaded through the bootstrap 
     * class loader.  The class is initialized only if the 
     * {</span><span class="s3">@code </span><span class="s0">initialize} parameter is {</span><span class="s3">@code </span><span class="s0">true} and if it has 
     * not been initialized earlier. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If {</span><span class="s3">@code </span><span class="s0">name} denotes a primitive type or void, an attempt 
     * will be made to locate a user-defined class in the unnamed package whose 
     * name is {</span><span class="s3">@code </span><span class="s0">name}. Therefore, this method cannot be used to 
     * obtain any of the {</span><span class="s3">@code </span><span class="s0">Class} objects representing primitive 
     * types or void. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If {</span><span class="s3">@code </span><span class="s0">name} denotes an array class, the component type of 
     * the array class is loaded but not initialized. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">For example, in an instance method the expression: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *  {</span><span class="s3">@code </span><span class="s0">Class.forName(&quot;Foo&quot;)} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * is equivalent to: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *  {</span><span class="s3">@code </span><span class="s0">Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * Note that this method throws errors related to loading, linking or 
     * initializing as specified in Sections 12.2, 12.3 and 12.4 of </span><span class="s4">&lt;em&gt;</span><span class="s0">The 
     * Java Language Specification</span><span class="s4">&lt;/em&gt;</span><span class="s0">. 
     * Note that this method does not check whether the requested class 
     * is accessible to its caller. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If the {</span><span class="s3">@code </span><span class="s0">loader} is {</span><span class="s3">@code </span><span class="s0">null}, and a security 
     * manager is present, and the caller's class loader is not null, then this 
     * method calls the security manager's {</span><span class="s3">@code </span><span class="s0">checkPermission} method 
     * with a {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;getClassLoader&quot;)} permission to 
     * ensure it's ok to access the bootstrap class loader. 
     * 
     * </span><span class="s3">@param </span><span class="s0">name       fully qualified name of the desired class 
     * </span><span class="s3">@param </span><span class="s0">initialize if {</span><span class="s3">@code </span><span class="s0">true} the class will be initialized. 
     *                   See Section 12.4 of </span><span class="s4">&lt;em&gt;</span><span class="s0">The Java Language Specification</span><span class="s4">&lt;/em&gt;</span><span class="s0">. 
     * </span><span class="s3">@param </span><span class="s0">loader     class loader from which the class must be loaded 
     * </span><span class="s3">@return           </span><span class="s0">class object representing the desired class 
     * 
     * </span><span class="s3">@exception </span><span class="s0">LinkageError if the linkage fails 
     * </span><span class="s3">@exception </span><span class="s0">ExceptionInInitializerError if the initialization provoked 
     *            by this method fails 
     * </span><span class="s3">@exception </span><span class="s0">ClassNotFoundException if the class cannot be located by 
     *            the specified class loader 
     * 
     * </span><span class="s3">@see       </span><span class="s0">java.lang.Class#forName(String) 
     * </span><span class="s3">@see       </span><span class="s0">java.lang.ClassLoader 
     * </span><span class="s3">@since     </span><span class="s0">1.2 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public static </span><span class="s1">Class&lt;?&gt; forName(String name, </span><span class="s2">boolean </span><span class="s1">initialize, 
                                   ClassLoader loader) 
        </span><span class="s2">throws </span><span class="s1">ClassNotFoundException 
    { 
        Class&lt;?&gt; caller = </span><span class="s2">null</span><span class="s1">; 
        SecurityManager sm = System.getSecurityManager(); 
        </span><span class="s2">if </span><span class="s1">(sm != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// Reflective call to get caller class is only needed if a security manager</span><span class="s1"> 
            </span><span class="s0">// is present.  Avoid the overhead of making this call otherwise.</span><span class="s1"> 
            caller = Reflection.getCallerClass(); 
            </span><span class="s2">if </span><span class="s1">(sun.misc.VM.isSystemDomainLoader(loader)) { 
                ClassLoader ccl = ClassLoader.getClassLoader(caller); 
                </span><span class="s2">if </span><span class="s1">(!sun.misc.VM.isSystemDomainLoader(ccl)) { 
                    sm.checkPermission( 
                        SecurityConstants.GET_CLASSLOADER_PERMISSION); 
                } 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">forName0(name, initialize, loader, caller); 
    } 
 
    </span><span class="s0">/** Called after security check for system loader access checks have been made. */</span><span class="s1"> 
    </span><span class="s2">private static native </span><span class="s1">Class&lt;?&gt; forName0(String name, </span><span class="s2">boolean </span><span class="s1">initialize, 
                                            ClassLoader loader, 
                                            Class&lt;?&gt; caller) 
        </span><span class="s2">throws </span><span class="s1">ClassNotFoundException; 
 
    </span><span class="s0">/** 
     * Creates a new instance of the class represented by this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object.  The class is instantiated as if by a {</span><span class="s3">@code </span><span class="s0">new} 
     * expression with an empty argument list.  The class is initialized if it 
     * has not already been initialized. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">Note that this method propagates any exception thrown by the 
     * nullary constructor, including a checked exception.  Use of 
     * this method effectively bypasses the compile-time exception 
     * checking that would otherwise be performed by the compiler. 
     * The {</span><span class="s3">@link</span><span class="s0"> 
     * java.lang.reflect.Constructor#newInstance(java.lang.Object...) 
     * Constructor.newInstance} method avoids this problem by wrapping 
     * any exception thrown by the constructor in a (checked) {</span><span class="s3">@link</span><span class="s0"> 
     * java.lang.reflect.InvocationTargetException}. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">a newly allocated instance of the class represented by this 
     *          object. 
     * </span><span class="s3">@throws  </span><span class="s0">IllegalAccessException  if the class or its nullary 
     *          constructor is not accessible. 
     * </span><span class="s3">@throws  </span><span class="s0">InstantiationException 
     *          if this {</span><span class="s3">@code </span><span class="s0">Class} represents an abstract class, 
     *          an interface, an array class, a primitive type, or void; 
     *          or if the class has no nullary constructor; 
     *          or if the instantiation fails for some other reason. 
     * </span><span class="s3">@throws  </span><span class="s0">ExceptionInInitializerError if the initialization 
     *          provoked by this method fails. 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *          the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class. 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">T newInstance() 
        </span><span class="s2">throws </span><span class="s1">InstantiationException, IllegalAccessException 
    { 
        </span><span class="s2">if </span><span class="s1">(System.getSecurityManager() != </span><span class="s2">null</span><span class="s1">) { 
            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">false</span><span class="s1">); 
        } 
 
        </span><span class="s0">// NOTE: the following code may not be strictly correct under</span><span class="s1"> 
        </span><span class="s0">// the current Java memory model.</span><span class="s1"> 
 
        </span><span class="s0">// Constructor lookup</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(cachedConstructor == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(</span><span class="s2">this </span><span class="s1">== Class.</span><span class="s2">class</span><span class="s1">) { 
                </span><span class="s2">throw new </span><span class="s1">IllegalAccessException( 
                    </span><span class="s6">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span><span class="s1"> 
                ); 
            } 
            </span><span class="s2">try </span><span class="s1">{ 
                Class&lt;?&gt;[] empty = {}; 
                </span><span class="s2">final </span><span class="s1">Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED); 
                </span><span class="s0">// Disable accessibility checks on the constructor</span><span class="s1"> 
                </span><span class="s0">// since we have to do the security check here anyway</span><span class="s1"> 
                </span><span class="s0">// (the stack depth is wrong for the Constructor's</span><span class="s1"> 
                </span><span class="s0">// security check to work)</span><span class="s1"> 
                java.security.AccessController.doPrivileged( 
                    </span><span class="s2">new </span><span class="s1">java.security.PrivilegedAction&lt;Void&gt;() { 
                        </span><span class="s2">public </span><span class="s1">Void run() { 
                                c.setAccessible(</span><span class="s2">true</span><span class="s1">); 
                                </span><span class="s2">return null</span><span class="s1">; 
                            } 
                        }); 
                cachedConstructor = c; 
            } </span><span class="s2">catch </span><span class="s1">(NoSuchMethodException e) { 
                </span><span class="s2">throw </span><span class="s1">(InstantiationException) 
                    </span><span class="s2">new </span><span class="s1">InstantiationException(getName()).initCause(e); 
            } 
        } 
        Constructor&lt;T&gt; tmpConstructor = cachedConstructor; 
        </span><span class="s0">// Security check (same as in java.lang.reflect.Constructor)</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">modifiers = tmpConstructor.getModifiers(); 
        </span><span class="s2">if </span><span class="s1">(!Reflection.quickCheckMemberAccess(</span><span class="s2">this</span><span class="s1">, modifiers)) { 
            Class&lt;?&gt; caller = Reflection.getCallerClass(); 
            </span><span class="s2">if </span><span class="s1">(newInstanceCallerCache != caller) { 
                Reflection.ensureMemberAccess(caller, </span><span class="s2">this</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, modifiers); 
                newInstanceCallerCache = caller; 
            } 
        } 
        </span><span class="s0">// Run constructor</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">return </span><span class="s1">tmpConstructor.newInstance((Object[])</span><span class="s2">null</span><span class="s1">); 
        } </span><span class="s2">catch </span><span class="s1">(InvocationTargetException e) { 
            Unsafe.getUnsafe().throwException(e.getTargetException()); 
            </span><span class="s0">// Not reached</span><span class="s1"> 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
    } 
    </span><span class="s2">private volatile transient </span><span class="s1">Constructor&lt;T&gt; cachedConstructor; 
    </span><span class="s2">private volatile transient </span><span class="s1">Class&lt;?&gt;       newInstanceCallerCache; 
 
 
    </span><span class="s0">/** 
     * Determines if the specified {</span><span class="s3">@code </span><span class="s0">Object} is assignment-compatible 
     * with the object represented by this {</span><span class="s3">@code </span><span class="s0">Class}.  This method is 
     * the dynamic equivalent of the Java language {</span><span class="s3">@code </span><span class="s0">instanceof} 
     * operator. The method returns {</span><span class="s3">@code </span><span class="s0">true} if the specified 
     * {</span><span class="s3">@code </span><span class="s0">Object} argument is non-null and can be cast to the 
     * reference type represented by this {</span><span class="s3">@code </span><span class="s0">Class} object without 
     * raising a {</span><span class="s3">@code </span><span class="s0">ClassCastException.} It returns {</span><span class="s3">@code </span><span class="s0">false} 
     * otherwise. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Specifically, if this {</span><span class="s3">@code </span><span class="s0">Class} object represents a 
     * declared class, this method returns {</span><span class="s3">@code </span><span class="s0">true} if the specified 
     * {</span><span class="s3">@code </span><span class="s0">Object} argument is an instance of the represented class (or 
     * of any of its subclasses); it returns {</span><span class="s3">@code </span><span class="s0">false} otherwise. If 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array class, this method 
     * returns {</span><span class="s3">@code </span><span class="s0">true} if the specified {</span><span class="s3">@code </span><span class="s0">Object} argument 
     * can be converted to an object of the array class by an identity 
     * conversion or by a widening reference conversion; it returns 
     * {</span><span class="s3">@code </span><span class="s0">false} otherwise. If this {</span><span class="s3">@code </span><span class="s0">Class} object 
     * represents an interface, this method returns {</span><span class="s3">@code </span><span class="s0">true} if the 
     * class or any superclass of the specified {</span><span class="s3">@code </span><span class="s0">Object} argument 
     * implements this interface; it returns {</span><span class="s3">@code </span><span class="s0">false} otherwise. If 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object represents a primitive type, this method 
     * returns {</span><span class="s3">@code </span><span class="s0">false}. 
     * 
     * </span><span class="s3">@param   </span><span class="s0">obj the object to check 
     * </span><span class="s3">@return  </span><span class="s0">true if {</span><span class="s3">@code </span><span class="s0">obj} is an instance of this class 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native boolean </span><span class="s1">isInstance(Object obj); 
 
 
    </span><span class="s0">/** 
     * Determines if the class or interface represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object is either the same as, or is a superclass or 
     * superinterface of, the class or interface represented by the specified 
     * {</span><span class="s3">@code </span><span class="s0">Class} parameter. It returns {</span><span class="s3">@code </span><span class="s0">true} if so; 
     * otherwise it returns {</span><span class="s3">@code </span><span class="s0">false}. If this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object represents a primitive type, this method returns 
     * {</span><span class="s3">@code </span><span class="s0">true} if the specified {</span><span class="s3">@code </span><span class="s0">Class} parameter is 
     * exactly this {</span><span class="s3">@code </span><span class="s0">Class} object; otherwise it returns 
     * {</span><span class="s3">@code </span><span class="s0">false}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Specifically, this method tests whether the type represented by the 
     * specified {</span><span class="s3">@code </span><span class="s0">Class} parameter can be converted to the type 
     * represented by this {</span><span class="s3">@code </span><span class="s0">Class} object via an identity conversion 
     * or via a widening reference conversion. See </span><span class="s4">&lt;em&gt;</span><span class="s0">The Java Language 
     * Specification</span><span class="s4">&lt;/em&gt;</span><span class="s0">, sections 5.1.1 and 5.1.4 , for details. 
     * 
     * </span><span class="s3">@param </span><span class="s0">cls the {</span><span class="s3">@code </span><span class="s0">Class} object to be checked 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">boolean} value indicating whether objects of the 
     * type {</span><span class="s3">@code </span><span class="s0">cls} can be assigned to objects of this class 
     * </span><span class="s3">@exception </span><span class="s0">NullPointerException if the specified Class parameter is 
     *            null. 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native boolean </span><span class="s1">isAssignableFrom(Class&lt;?&gt; cls); 
 
 
    </span><span class="s0">/** 
     * Determines if the specified {</span><span class="s3">@code </span><span class="s0">Class} object represents an 
     * interface type. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if this object represents an interface; 
     *          {</span><span class="s3">@code </span><span class="s0">false} otherwise. 
     */</span><span class="s1"> 
    </span><span class="s2">public native boolean </span><span class="s1">isInterface(); 
 
 
    </span><span class="s0">/** 
     * Determines if this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array class. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if this object represents an array class; 
     *          {</span><span class="s3">@code </span><span class="s0">false} otherwise. 
     * </span><span class="s3">@since   </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native boolean </span><span class="s1">isArray(); 
 
 
    </span><span class="s0">/** 
     * Determines if the specified {</span><span class="s3">@code </span><span class="s0">Class} object represents a 
     * primitive type. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">There are nine predefined {</span><span class="s3">@code </span><span class="s0">Class} objects to represent 
     * the eight primitive types and void.  These are created by the Java 
     * Virtual Machine, and have the same names as the primitive types that 
     * they represent, namely {</span><span class="s3">@code </span><span class="s0">boolean}, {</span><span class="s3">@code </span><span class="s0">byte}, 
     * {</span><span class="s3">@code </span><span class="s0">char}, {</span><span class="s3">@code </span><span class="s0">short}, {</span><span class="s3">@code </span><span class="s0">int}, 
     * {</span><span class="s3">@code </span><span class="s0">long}, {</span><span class="s3">@code </span><span class="s0">float}, and {</span><span class="s3">@code </span><span class="s0">double}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">These objects may only be accessed via the following public static 
     * final variables, and are the only {</span><span class="s3">@code </span><span class="s0">Class} objects for which 
     * this method returns {</span><span class="s3">@code </span><span class="s0">true}. 
     * 
     * </span><span class="s3">@return </span><span class="s0">true if and only if this class represents a primitive type 
     * 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Boolean#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Character#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Byte#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Short#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Integer#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Long#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Float#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Double#TYPE 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.Void#TYPE 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native boolean </span><span class="s1">isPrimitive(); 
 
    </span><span class="s0">/** 
     * Returns true if this {</span><span class="s3">@code </span><span class="s0">Class} object represents an annotation 
     * type.  Note that if this method returns true, {</span><span class="s3">@link </span><span class="s0">#isInterface()} 
     * would also return true, as all annotation types are also interfaces. 
     * 
     * </span><span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if this class object represents an annotation 
     *      type; {</span><span class="s3">@code </span><span class="s0">false} otherwise 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isAnnotation() { 
        </span><span class="s2">return </span><span class="s1">(getModifiers() &amp; ANNOTATION) != </span><span class="s5">0</span><span class="s1">; 
    } 
 
    </span><span class="s0">/** 
     * Returns {</span><span class="s3">@code </span><span class="s0">true} if this class is a synthetic class; 
     * returns {</span><span class="s3">@code </span><span class="s0">false} otherwise. 
     * </span><span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if and only if this class is a synthetic class as 
     *         defined by the Java Language Specification. 
     * </span><span class="s3">@jls </span><span class="s0">13.1 The Form of a Binary 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isSynthetic() { 
        </span><span class="s2">return </span><span class="s1">(getModifiers() &amp; SYNTHETIC) != </span><span class="s5">0</span><span class="s1">; 
    } 
 
    </span><span class="s0">/** 
     * Returns the  name of the entity (class, interface, array class, 
     * primitive type, or void) represented by this {</span><span class="s3">@code </span><span class="s0">Class} object, 
     * as a {</span><span class="s3">@code </span><span class="s0">String}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this class object represents a reference type that is not an 
     * array type then the binary name of the class is returned, as specified 
     * by 
     * </span><span class="s4">&lt;cite&gt;</span><span class="s0">The Java</span><span class="s1">&amp;trade; </span><span class="s0">Language Specification</span><span class="s4">&lt;/cite&gt;</span><span class="s0">. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this class object represents a primitive type or void, then the 
     * name returned is a {</span><span class="s3">@code </span><span class="s0">String} equal to the Java language 
     * keyword corresponding to the primitive type or void. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this class object represents a class of arrays, then the internal 
     * form of the name consists of the name of the element type preceded by 
     * one or more '{</span><span class="s3">@code </span><span class="s0">[}' characters representing the depth of the array 
     * nesting.  The encoding of element type names is as follows: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;&lt;table summary=&quot;Element types and encodings&quot;&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;tr&gt;&lt;th&gt; </span><span class="s0">Element Type </span><span class="s4">&lt;th&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;th&gt; </span><span class="s0">Encoding 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">boolean      </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">Z 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">byte         </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">B 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">char         </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">C 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">class or interface 
     *                       </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">L</span><span class="s4">&lt;i&gt;</span><span class="s0">classname</span><span class="s4">&lt;/i&gt;</span><span class="s0">; 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">double       </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">D 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">float        </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">F 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">int          </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">I 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">long         </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">J 
     * </span><span class="s4">&lt;tr&gt;&lt;td&gt; </span><span class="s0">short        </span><span class="s4">&lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; </span><span class="s0">S 
     * </span><span class="s4">&lt;/table&gt;&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The class or interface name </span><span class="s4">&lt;i&gt;</span><span class="s0">classname</span><span class="s4">&lt;/i&gt; </span><span class="s0">is the binary name of 
     * the class specified above. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Examples: 
     * </span><span class="s4">&lt;blockquote&gt;&lt;pre&gt;</span><span class="s0"> 
     * String.class.getName() 
     *     returns &quot;java.lang.String&quot; 
     * byte.class.getName() 
     *     returns &quot;byte&quot; 
     * (new Object[3]).getClass().getName() 
     *     returns &quot;[Ljava.lang.Object;&quot; 
     * (new int[3][4][5][6][7][8][9]).getClass().getName() 
     *     returns &quot;[[[[[[[I&quot; 
     * </span><span class="s4">&lt;/pre&gt;&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the name of the class or interface 
     *          represented by this object. 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String getName() { 
        String name = </span><span class="s2">this</span><span class="s1">.name; 
        </span><span class="s2">if </span><span class="s1">(name == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">this</span><span class="s1">.name = name = getName0(); 
        </span><span class="s2">return </span><span class="s1">name; 
    } 
 
    </span><span class="s0">// cache the name to reduce the number of calls into the VM</span><span class="s1"> 
    </span><span class="s2">private transient </span><span class="s1">String name; 
    </span><span class="s2">private native </span><span class="s1">String getName0(); 
 
    </span><span class="s0">/** 
     * Returns the class loader for the class.  Some implementations may use 
     * null to represent the bootstrap class loader. This method will return 
     * null in such implementations if this class was loaded by the bootstrap 
     * class loader. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If a security manager is present, and the caller's class loader is 
     * not null and the caller's class loader is not the same as or an ancestor of 
     * the class loader for the class whose class loader is requested, then 
     * this method calls the security manager's {</span><span class="s3">@code </span><span class="s0">checkPermission} 
     * method with a {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;getClassLoader&quot;)} 
     * permission to ensure it's ok to access the class loader for the class. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If this object 
     * represents a primitive type or void, null is returned. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the class loader that loaded the class or interface 
     *          represented by this object. 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *    if a security manager exists and its 
     *    {</span><span class="s3">@code </span><span class="s0">checkPermission} method denies 
     *    access to the class loader for the class. 
     * </span><span class="s3">@see </span><span class="s0">java.lang.ClassLoader 
     * </span><span class="s3">@see </span><span class="s0">SecurityManager#checkPermission 
     * </span><span class="s3">@see </span><span class="s0">java.lang.RuntimePermission 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">ClassLoader getClassLoader() { 
        ClassLoader cl = getClassLoader0(); 
        </span><span class="s2">if </span><span class="s1">(cl == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return null</span><span class="s1">; 
        SecurityManager sm = System.getSecurityManager(); 
        </span><span class="s2">if </span><span class="s1">(sm != </span><span class="s2">null</span><span class="s1">) { 
            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); 
        } 
        </span><span class="s2">return </span><span class="s1">cl; 
    } 
 
    </span><span class="s0">// Package-private to allow ClassLoader access</span><span class="s1"> 
    ClassLoader getClassLoader0() { </span><span class="s2">return </span><span class="s1">classLoader; } 
 
    </span><span class="s0">// Initialized in JVM not by private constructor</span><span class="s1"> 
    </span><span class="s0">// This field is filtered from reflection access, i.e. getDeclaredField</span><span class="s1"> 
    </span><span class="s0">// will throw NoSuchFieldException</span><span class="s1"> 
    </span><span class="s2">private final </span><span class="s1">ClassLoader classLoader; 
 
    </span><span class="s0">/** 
     * Returns an array of {</span><span class="s3">@code </span><span class="s0">TypeVariable} objects that represent the 
     * type variables declared by the generic declaration represented by this 
     * {</span><span class="s3">@code </span><span class="s0">GenericDeclaration} object, in declaration order.  Returns an 
     * array of length 0 if the underlying generic declaration declares no type 
     * variables. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an array of {</span><span class="s3">@code </span><span class="s0">TypeVariable} objects that represent 
     *     the type variables declared by this generic declaration 
     * </span><span class="s3">@throws </span><span class="s0">java.lang.reflect.GenericSignatureFormatError if the generic 
     *     signature of this generic declaration does not conform to 
     *     the format specified in 
     *     </span><span class="s4">&lt;cite&gt;</span><span class="s0">The Java</span><span class="s1">&amp;trade; </span><span class="s0">Virtual Machine Specification</span><span class="s4">&lt;/cite&gt;</span><span class="s0"> 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
    </span><span class="s2">public </span><span class="s1">TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() { 
        ClassRepository info = getGenericInfo(); 
        </span><span class="s2">if </span><span class="s1">(info != </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return </span><span class="s1">(TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters(); 
        </span><span class="s2">else</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">(TypeVariable&lt;Class&lt;T&gt;&gt;[])</span><span class="s2">new </span><span class="s1">TypeVariable&lt;?&gt;[</span><span class="s5">0</span><span class="s1">]; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Class} representing the superclass of the entity 
     * (class, interface, primitive type or void) represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class}.  If this {</span><span class="s3">@code </span><span class="s0">Class} represents either the 
     * {</span><span class="s3">@code </span><span class="s0">Object} class, an interface, a primitive type, or void, then 
     * null is returned.  If this object represents an array class then the 
     * {</span><span class="s3">@code </span><span class="s0">Class} object representing the {</span><span class="s3">@code </span><span class="s0">Object} class is 
     * returned. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the superclass of the class represented by this object. 
     */</span><span class="s1"> 
    </span><span class="s2">public native </span><span class="s1">Class&lt;? </span><span class="s2">super </span><span class="s1">T&gt; getSuperclass(); 
 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Type} representing the direct superclass of 
     * the entity (class, interface, primitive type or void) represented by 
     * this {</span><span class="s3">@code </span><span class="s0">Class}. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If the superclass is a parameterized type, the {</span><span class="s3">@code </span><span class="s0">Type} 
     * object returned must accurately reflect the actual type 
     * parameters used in the source code. The parameterized type 
     * representing the superclass is created if it had not been 
     * created before. See the declaration of {</span><span class="s3">@link</span><span class="s0"> 
     * java.lang.reflect.ParameterizedType ParameterizedType} for the 
     * semantics of the creation process for parameterized types.  If 
     * this {</span><span class="s3">@code </span><span class="s0">Class} represents either the {</span><span class="s3">@code </span><span class="s0">Object} 
     * class, an interface, a primitive type, or void, then null is 
     * returned.  If this object represents an array class then the 
     * {</span><span class="s3">@code </span><span class="s0">Class} object representing the {</span><span class="s3">@code </span><span class="s0">Object} class is 
     * returned. 
     * 
     * </span><span class="s3">@throws </span><span class="s0">java.lang.reflect.GenericSignatureFormatError if the generic 
     *     class signature does not conform to the format specified in 
     *     </span><span class="s4">&lt;cite&gt;</span><span class="s0">The Java</span><span class="s1">&amp;trade; </span><span class="s0">Virtual Machine Specification</span><span class="s4">&lt;/cite&gt;</span><span class="s0"> 
     * </span><span class="s3">@throws </span><span class="s0">TypeNotPresentException if the generic superclass 
     *     refers to a non-existent type declaration 
     * </span><span class="s3">@throws </span><span class="s0">java.lang.reflect.MalformedParameterizedTypeException if the 
     *     generic superclass refers to a parameterized type that cannot be 
     *     instantiated  for any reason 
     * </span><span class="s3">@return </span><span class="s0">the superclass of the class represented by this object 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Type getGenericSuperclass() { 
        ClassRepository info = getGenericInfo(); 
        </span><span class="s2">if </span><span class="s1">(info == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">getSuperclass(); 
        } 
 
        </span><span class="s0">// Historical irregularity:</span><span class="s1"> 
        </span><span class="s0">// Generic signature marks interfaces with superclass = Object</span><span class="s1"> 
        </span><span class="s0">// but this API returns null for interfaces</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(isInterface()) { 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
 
        </span><span class="s2">return </span><span class="s1">info.getSuperclass(); 
    } 
 
    </span><span class="s0">/** 
     * Gets the package for this class.  The class loader of this class is used 
     * to find the package.  If the class was loaded by the bootstrap class 
     * loader the set of packages loaded from CLASSPATH is searched to find the 
     * package of the class. Null is returned if no package object was created 
     * by the class loader of this class. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Packages have attributes for versions and specifications only if the 
     * information was defined in the manifests that accompany the classes, and 
     * if the class loader created the package instance with the attributes 
     * from the manifest. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the package of the class, or null if no package 
     *         information is available from the archive or codebase. 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Package getPackage() { 
        </span><span class="s2">return </span><span class="s1">Package.getPackage(</span><span class="s2">this</span><span class="s1">); 
    } 
 
 
    </span><span class="s0">/** 
     * Determines the interfaces implemented by the class or interface 
     * represented by this object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this object represents a class, the return value is an array 
     * containing objects representing all interfaces implemented by the 
     * class. The order of the interface objects in the array corresponds to 
     * the order of the interface names in the {</span><span class="s3">@code </span><span class="s0">implements} clause 
     * of the declaration of the class represented by this object. For 
     * example, given the declaration: 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     * {</span><span class="s3">@code </span><span class="s0">class Shimmer implements FloorWax, DessertTopping { ... }} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * suppose the value of {</span><span class="s3">@code </span><span class="s0">s} is an instance of 
     * {</span><span class="s3">@code </span><span class="s0">Shimmer}; the value of the expression: 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     * {</span><span class="s3">@code </span><span class="s0">s.getClass().getInterfaces()[0]} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * is the {</span><span class="s3">@code </span><span class="s0">Class} object that represents interface 
     * {</span><span class="s3">@code </span><span class="s0">FloorWax}; and the value of: 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     * {</span><span class="s3">@code </span><span class="s0">s.getClass().getInterfaces()[1]} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * is the {</span><span class="s3">@code </span><span class="s0">Class} object that represents interface 
     * {</span><span class="s3">@code </span><span class="s0">DessertTopping}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this object represents an interface, the array contains objects 
     * representing all interfaces extended by the interface. The order of the 
     * interface objects in the array corresponds to the order of the interface 
     * names in the {</span><span class="s3">@code </span><span class="s0">extends} clause of the declaration of the 
     * interface represented by this object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this object represents a class or interface that implements no 
     * interfaces, the method returns an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this object represents a primitive type or void, the method 
     * returns an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, the 
     * interfaces {</span><span class="s3">@code </span><span class="s0">Cloneable} and {</span><span class="s3">@code </span><span class="s0">java.io.Serializable} are 
     * returned in that order. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an array of interfaces implemented by this class. 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Class&lt;?&gt;[] getInterfaces() { 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// no cloning required</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">getInterfaces0(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            Class&lt;?&gt;[] interfaces = rd.interfaces; 
            </span><span class="s2">if </span><span class="s1">(interfaces == </span><span class="s2">null</span><span class="s1">) { 
                interfaces = getInterfaces0(); 
                rd.interfaces = interfaces; 
            } 
            </span><span class="s0">// defensively copy before handing over to user code</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">interfaces.clone(); 
        } 
    } 
 
    </span><span class="s2">private native </span><span class="s1">Class&lt;?&gt;[] getInterfaces0(); 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Type}s representing the interfaces 
     * directly implemented by the class or interface represented by 
     * this object. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If a superinterface is a parameterized type, the 
     * {</span><span class="s3">@code </span><span class="s0">Type} object returned for it must accurately reflect 
     * the actual type parameters used in the source code. The 
     * parameterized type representing each superinterface is created 
     * if it had not been created before. See the declaration of 
     * {</span><span class="s3">@link </span><span class="s0">java.lang.reflect.ParameterizedType ParameterizedType} 
     * for the semantics of the creation process for parameterized 
     * types. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this object represents a class, the return value is an 
     * array containing objects representing all interfaces 
     * implemented by the class. The order of the interface objects in 
     * the array corresponds to the order of the interface names in 
     * the {</span><span class="s3">@code </span><span class="s0">implements} clause of the declaration of the class 
     * represented by this object.  In the case of an array class, the 
     * interfaces {</span><span class="s3">@code </span><span class="s0">Cloneable} and {</span><span class="s3">@code </span><span class="s0">Serializable} are 
     * returned in that order. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If this object represents an interface, the array contains 
     * objects representing all interfaces directly extended by the 
     * interface.  The order of the interface objects in the array 
     * corresponds to the order of the interface names in the 
     * {</span><span class="s3">@code </span><span class="s0">extends} clause of the declaration of the interface 
     * represented by this object. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If this object represents a class or interface that 
     * implements no interfaces, the method returns an array of length 
     * 0. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">If this object represents a primitive type or void, the 
     * method returns an array of length 0. 
     * 
     * </span><span class="s3">@throws </span><span class="s0">java.lang.reflect.GenericSignatureFormatError 
     *     if the generic class signature does not conform to the format 
     *     specified in 
     *     </span><span class="s4">&lt;cite&gt;</span><span class="s0">The Java</span><span class="s1">&amp;trade; </span><span class="s0">Virtual Machine Specification</span><span class="s4">&lt;/cite&gt;</span><span class="s0"> 
     * </span><span class="s3">@throws </span><span class="s0">TypeNotPresentException if any of the generic 
     *     superinterfaces refers to a non-existent type declaration 
     * </span><span class="s3">@throws </span><span class="s0">java.lang.reflect.MalformedParameterizedTypeException 
     *     if any of the generic superinterfaces refer to a parameterized 
     *     type that cannot be instantiated for any reason 
     * </span><span class="s3">@return </span><span class="s0">an array of interfaces implemented by this class 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Type[] getGenericInterfaces() { 
        ClassRepository info = getGenericInfo(); 
        </span><span class="s2">return </span><span class="s1">(info == </span><span class="s2">null</span><span class="s1">) ?  getInterfaces() : info.getSuperInterfaces(); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">Class} representing the component type of an 
     * array.  If this class does not represent an array class this method 
     * returns null. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Class} representing the component type of this 
     * class if this class is an array 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.reflect.Array 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native </span><span class="s1">Class&lt;?&gt; getComponentType(); 
 
 
    </span><span class="s0">/** 
     * Returns the Java language modifiers for this class or interface, encoded 
     * in an integer. The modifiers consist of the Java Virtual Machine's 
     * constants for {</span><span class="s3">@code </span><span class="s0">public}, {</span><span class="s3">@code </span><span class="s0">protected}, 
     * {</span><span class="s3">@code </span><span class="s0">private}, {</span><span class="s3">@code </span><span class="s0">final}, {</span><span class="s3">@code </span><span class="s0">static}, 
     * {</span><span class="s3">@code </span><span class="s0">abstract} and {</span><span class="s3">@code </span><span class="s0">interface}; they should be decoded 
     * using the methods of class {</span><span class="s3">@code </span><span class="s0">Modifier}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If the underlying class is an array class, then its 
     * {</span><span class="s3">@code </span><span class="s0">public}, {</span><span class="s3">@code </span><span class="s0">private} and {</span><span class="s3">@code </span><span class="s0">protected} 
     * modifiers are the same as those of its component type.  If this 
     * {</span><span class="s3">@code </span><span class="s0">Class} represents a primitive type or void, its 
     * {</span><span class="s3">@code </span><span class="s0">public} modifier is always {</span><span class="s3">@code </span><span class="s0">true}, and its 
     * {</span><span class="s3">@code </span><span class="s0">protected} and {</span><span class="s3">@code </span><span class="s0">private} modifiers are always 
     * {</span><span class="s3">@code </span><span class="s0">false}. If this object represents an array class, a 
     * primitive type or void, then its {</span><span class="s3">@code </span><span class="s0">final} modifier is always 
     * {</span><span class="s3">@code </span><span class="s0">true} and its interface modifier is always 
     * {</span><span class="s3">@code </span><span class="s0">false}. The values of its other modifiers are not determined 
     * by this specification. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The modifier encodings are defined in </span><span class="s4">&lt;em&gt;</span><span class="s0">The Java Virtual Machine 
     * Specification</span><span class="s4">&lt;/em&gt;</span><span class="s0">, table 4.1. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">int} representing the modifiers for this class 
     * </span><span class="s3">@see     </span><span class="s0">java.lang.reflect.Modifier 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native int </span><span class="s1">getModifiers(); 
 
 
    </span><span class="s0">/** 
     * Gets the signers of this class. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the signers of this class, or null if there are no signers.  In 
     *          particular, this method returns null if this object represents 
     *          a primitive type or void. 
     * </span><span class="s3">@since   </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public native </span><span class="s1">Object[] getSigners(); 
 
 
    </span><span class="s0">/** 
     * Set the signers of this class. 
     */</span><span class="s1"> 
    </span><span class="s2">native void </span><span class="s1">setSigners(Object[] signers); 
 
 
    </span><span class="s0">/** 
     * If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a local or anonymous 
     * class within a method, returns a {</span><span class="s3">@link</span><span class="s0"> 
     * java.lang.reflect.Method Method} object representing the 
     * immediately enclosing method of the underlying class. Returns 
     * {</span><span class="s3">@code </span><span class="s0">null} otherwise. 
     * 
     * In particular, this method returns {</span><span class="s3">@code </span><span class="s0">null} if the underlying 
     * class is a local or anonymous class immediately enclosed by a type 
     * declaration, instance initializer or static initializer. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the immediately enclosing method of the underlying class, if 
     *     that class is a local or anonymous class; otherwise {</span><span class="s3">@code </span><span class="s0">null}. 
     * 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *         following conditions is met: 
     * 
     *         </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *         class loader of the enclosing class and invocation of 
     *         {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *         s.checkPermission} method with 
     *         {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *         denies access to the methods within the enclosing class 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the enclosing class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of the enclosing class 
     * 
     *         </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Method getEnclosingMethod() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo(); 
 
        </span><span class="s2">if </span><span class="s1">(enclosingInfo == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return null</span><span class="s1">; 
        </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">if </span><span class="s1">(!enclosingInfo.isMethod()) 
                </span><span class="s2">return null</span><span class="s1">; 
 
            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(), 
                                                              getFactory()); 
            Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType()); 
            Type []    parameterTypes   = typeInfo.getParameterTypes(); 
            Class&lt;?&gt;[] parameterClasses = </span><span class="s2">new </span><span class="s1">Class&lt;?&gt;[parameterTypes.length]; 
 
            </span><span class="s0">// Convert Types to Classes; returned types *should*</span><span class="s1"> 
            </span><span class="s0">// be class objects since the methodDescriptor's used</span><span class="s1"> 
            </span><span class="s0">// don't have generics information</span><span class="s1"> 
            </span><span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; parameterClasses.length; i++) 
                parameterClasses[i] = toClass(parameterTypes[i]); 
 
            </span><span class="s0">// Perform access check</span><span class="s1"> 
            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass(); 
            enclosingCandidate.checkMemberAccess(Member.DECLARED, 
                                                 Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
            </span><span class="s0">/* 
             * Loop over all declared methods; match method name, 
             * number of and type of parameters, *and* return 
             * type.  Matching return type is also necessary 
             * because of covariant returns, etc. 
             */</span><span class="s1"> 
            </span><span class="s2">for</span><span class="s1">(Method m: enclosingCandidate.getDeclaredMethods()) { 
                </span><span class="s2">if </span><span class="s1">(m.getName().equals(enclosingInfo.getName()) ) { 
                    Class&lt;?&gt;[] candidateParamClasses = m.getParameterTypes(); 
                    </span><span class="s2">if </span><span class="s1">(candidateParamClasses.length == parameterClasses.length) { 
                        </span><span class="s2">boolean </span><span class="s1">matches = </span><span class="s2">true</span><span class="s1">; 
                        </span><span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; candidateParamClasses.length; i++) { 
                            </span><span class="s2">if </span><span class="s1">(!candidateParamClasses[i].equals(parameterClasses[i])) { 
                                matches = </span><span class="s2">false</span><span class="s1">; 
                                </span><span class="s2">break</span><span class="s1">; 
                            } 
                        } 
 
                        </span><span class="s2">if </span><span class="s1">(matches) { </span><span class="s0">// finally, check return type</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">(m.getReturnType().equals(returnType) ) 
                                </span><span class="s2">return </span><span class="s1">m; 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Enclosing method not found&quot;</span><span class="s1">); 
        } 
    } 
 
    </span><span class="s2">private native </span><span class="s1">Object[] getEnclosingMethod0(); 
 
    </span><span class="s2">private </span><span class="s1">EnclosingMethodInfo getEnclosingMethodInfo() { 
        Object[] enclosingInfo = getEnclosingMethod0(); 
        </span><span class="s2">if </span><span class="s1">(enclosingInfo == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return null</span><span class="s1">; 
        </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">return new </span><span class="s1">EnclosingMethodInfo(enclosingInfo); 
        } 
    } 
 
    </span><span class="s2">private final static class </span><span class="s1">EnclosingMethodInfo { 
        </span><span class="s2">private </span><span class="s1">Class&lt;?&gt; enclosingClass; 
        </span><span class="s2">private </span><span class="s1">String name; 
        </span><span class="s2">private </span><span class="s1">String descriptor; 
 
        </span><span class="s2">private </span><span class="s1">EnclosingMethodInfo(Object[] enclosingInfo) { 
            </span><span class="s2">if </span><span class="s1">(enclosingInfo.length != </span><span class="s5">3</span><span class="s1">) 
                </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Malformed enclosing method information&quot;</span><span class="s1">); 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s0">// The array is expected to have three elements:</span><span class="s1"> 
 
                </span><span class="s0">// the immediately enclosing class</span><span class="s1"> 
                enclosingClass = (Class&lt;?&gt;) enclosingInfo[</span><span class="s5">0</span><span class="s1">]; 
                </span><span class="s2">assert</span><span class="s1">(enclosingClass != </span><span class="s2">null</span><span class="s1">); 
 
                </span><span class="s0">// the immediately enclosing method or constructor's</span><span class="s1"> 
                </span><span class="s0">// name (can be null).</span><span class="s1"> 
                name            = (String)   enclosingInfo[</span><span class="s5">1</span><span class="s1">]; 
 
                </span><span class="s0">// the immediately enclosing method or constructor's</span><span class="s1"> 
                </span><span class="s0">// descriptor (null iff name is).</span><span class="s1"> 
                descriptor      = (String)   enclosingInfo[</span><span class="s5">2</span><span class="s1">]; 
                </span><span class="s2">assert</span><span class="s1">((name != </span><span class="s2">null </span><span class="s1">&amp;&amp; descriptor != </span><span class="s2">null</span><span class="s1">) || name == descriptor); 
            } </span><span class="s2">catch </span><span class="s1">(ClassCastException cce) { 
                </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Invalid type in enclosing method information&quot;</span><span class="s1">, cce); 
            } 
        } 
 
        </span><span class="s2">boolean </span><span class="s1">isPartial() { 
            </span><span class="s2">return </span><span class="s1">enclosingClass == </span><span class="s2">null </span><span class="s1">|| name == </span><span class="s2">null </span><span class="s1">|| descriptor == </span><span class="s2">null</span><span class="s1">; 
        } 
 
        </span><span class="s2">boolean </span><span class="s1">isConstructor() { </span><span class="s2">return </span><span class="s1">!isPartial() &amp;&amp; </span><span class="s6">&quot;&lt;init&gt;&quot;</span><span class="s1">.equals(name); } 
 
        </span><span class="s2">boolean </span><span class="s1">isMethod() { </span><span class="s2">return </span><span class="s1">!isPartial() &amp;&amp; !isConstructor() &amp;&amp; !</span><span class="s6">&quot;&lt;clinit&gt;&quot;</span><span class="s1">.equals(name); } 
 
        Class&lt;?&gt; getEnclosingClass() { </span><span class="s2">return </span><span class="s1">enclosingClass; } 
 
        String getName() { </span><span class="s2">return </span><span class="s1">name; } 
 
        String getDescriptor() { </span><span class="s2">return </span><span class="s1">descriptor; } 
 
    } 
 
    </span><span class="s2">private static </span><span class="s1">Class&lt;?&gt; toClass(Type o) { 
        </span><span class="s2">if </span><span class="s1">(o </span><span class="s2">instanceof </span><span class="s1">GenericArrayType) 
            </span><span class="s2">return </span><span class="s1">Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()), 
                                     </span><span class="s5">0</span><span class="s1">) 
                .getClass(); 
        </span><span class="s2">return </span><span class="s1">(Class&lt;?&gt;)o; 
     } 
 
    </span><span class="s0">/** 
     * If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a local or anonymous 
     * class within a constructor, returns a {</span><span class="s3">@link</span><span class="s0"> 
     * java.lang.reflect.Constructor Constructor} object representing 
     * the immediately enclosing constructor of the underlying 
     * class. Returns {</span><span class="s3">@code </span><span class="s0">null} otherwise.  In particular, this 
     * method returns {</span><span class="s3">@code </span><span class="s0">null} if the underlying class is a local 
     * or anonymous class immediately enclosed by a type declaration, 
     * instance initializer or static initializer. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the immediately enclosing constructor of the underlying class, if 
     *     that class is a local or anonymous class; otherwise {</span><span class="s3">@code </span><span class="s0">null}. 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *         following conditions is met: 
     * 
     *         </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *         class loader of the enclosing class and invocation of 
     *         {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *         s.checkPermission} method with 
     *         {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *         denies access to the constructors within the enclosing class 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the enclosing class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of the enclosing class 
     * 
     *         </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Constructor&lt;?&gt; getEnclosingConstructor() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo(); 
 
        </span><span class="s2">if </span><span class="s1">(enclosingInfo == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return null</span><span class="s1">; 
        </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">if </span><span class="s1">(!enclosingInfo.isConstructor()) 
                </span><span class="s2">return null</span><span class="s1">; 
 
            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(), 
                                                                        getFactory()); 
            Type []    parameterTypes   = typeInfo.getParameterTypes(); 
            Class&lt;?&gt;[] parameterClasses = </span><span class="s2">new </span><span class="s1">Class&lt;?&gt;[parameterTypes.length]; 
 
            </span><span class="s0">// Convert Types to Classes; returned types *should*</span><span class="s1"> 
            </span><span class="s0">// be class objects since the methodDescriptor's used</span><span class="s1"> 
            </span><span class="s0">// don't have generics information</span><span class="s1"> 
            </span><span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; parameterClasses.length; i++) 
                parameterClasses[i] = toClass(parameterTypes[i]); 
 
            </span><span class="s0">// Perform access check</span><span class="s1"> 
            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass(); 
            enclosingCandidate.checkMemberAccess(Member.DECLARED, 
                                                 Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
            </span><span class="s0">/* 
             * Loop over all declared constructors; match number 
             * of and type of parameters. 
             */</span><span class="s1"> 
            </span><span class="s2">for</span><span class="s1">(Constructor&lt;?&gt; c: enclosingCandidate.getDeclaredConstructors()) { 
                Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes(); 
                </span><span class="s2">if </span><span class="s1">(candidateParamClasses.length == parameterClasses.length) { 
                    </span><span class="s2">boolean </span><span class="s1">matches = </span><span class="s2">true</span><span class="s1">; 
                    </span><span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; candidateParamClasses.length; i++) { 
                        </span><span class="s2">if </span><span class="s1">(!candidateParamClasses[i].equals(parameterClasses[i])) { 
                            matches = </span><span class="s2">false</span><span class="s1">; 
                            </span><span class="s2">break</span><span class="s1">; 
                        } 
                    } 
 
                    </span><span class="s2">if </span><span class="s1">(matches) 
                        </span><span class="s2">return </span><span class="s1">c; 
                } 
            } 
 
            </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Enclosing constructor not found&quot;</span><span class="s1">); 
        } 
    } 
 
 
    </span><span class="s0">/** 
     * If the class or interface represented by this {</span><span class="s3">@code </span><span class="s0">Class} object 
     * is a member of another class, returns the {</span><span class="s3">@code </span><span class="s0">Class} object 
     * representing the class in which it was declared.  This method returns 
     * null if this class or interface is not a member of any other class.  If 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array class, a primitive 
     * type, or void,then this method returns null. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the declaring class for this class 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and the caller's 
     *         class loader is not the same as or an ancestor of the class 
     *         loader for the declaring class and invocation of {</span><span class="s3">@link</span><span class="s0"> 
     *         SecurityManager#checkPackageAccess s.checkPackageAccess()} 
     *         denies access to the package of the declaring class 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Class&lt;?&gt; getDeclaringClass() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        </span><span class="s2">final </span><span class="s1">Class&lt;?&gt; candidate = getDeclaringClass0(); 
 
        </span><span class="s2">if </span><span class="s1">(candidate != </span><span class="s2">null</span><span class="s1">) 
            candidate.checkPackageAccess( 
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">candidate; 
    } 
 
    </span><span class="s2">private native </span><span class="s1">Class&lt;?&gt; getDeclaringClass0(); 
 
 
    </span><span class="s0">/** 
     * Returns the immediately enclosing class of the underlying 
     * class.  If the underlying class is a top level class this 
     * method returns {</span><span class="s3">@code </span><span class="s0">null}. 
     * </span><span class="s3">@return </span><span class="s0">the immediately enclosing class of the underlying class 
     * </span><span class="s3">@exception  </span><span class="s0">SecurityException 
     *             If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and the caller's 
     *             class loader is not the same as or an ancestor of the class 
     *             loader for the enclosing class and invocation of {</span><span class="s3">@link</span><span class="s0"> 
     *             SecurityManager#checkPackageAccess s.checkPackageAccess()} 
     *             denies access to the package of the enclosing class 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Class&lt;?&gt; getEnclosingClass() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        </span><span class="s0">// There are five kinds of classes (or interfaces):</span><span class="s1"> 
        </span><span class="s0">// a) Top level classes</span><span class="s1"> 
        </span><span class="s0">// b) Nested classes (static member classes)</span><span class="s1"> 
        </span><span class="s0">// c) Inner classes (non-static member classes)</span><span class="s1"> 
        </span><span class="s0">// d) Local classes (named classes declared within a method)</span><span class="s1"> 
        </span><span class="s0">// e) Anonymous classes</span><span class="s1"> 
 
 
        </span><span class="s0">// JVM Spec 4.8.6: A class must have an EnclosingMethod</span><span class="s1"> 
        </span><span class="s0">// attribute if and only if it is a local class or an</span><span class="s1"> 
        </span><span class="s0">// anonymous class.</span><span class="s1"> 
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo(); 
        Class&lt;?&gt; enclosingCandidate; 
 
        </span><span class="s2">if </span><span class="s1">(enclosingInfo == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// This is a top level or a nested class or an inner class (a, b, or c)</span><span class="s1"> 
            enclosingCandidate = getDeclaringClass(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass(); 
            </span><span class="s0">// This is a local class or an anonymous class (d or e)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">(enclosingClass == </span><span class="s2">this </span><span class="s1">|| enclosingClass == </span><span class="s2">null</span><span class="s1">) 
                </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Malformed enclosing method information&quot;</span><span class="s1">); 
            </span><span class="s2">else</span><span class="s1"> 
                enclosingCandidate = enclosingClass; 
        } 
 
        </span><span class="s2">if </span><span class="s1">(enclosingCandidate != </span><span class="s2">null</span><span class="s1">) 
            enclosingCandidate.checkPackageAccess( 
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">enclosingCandidate; 
    } 
 
    </span><span class="s0">/** 
     * Returns the simple name of the underlying class as given in the 
     * source code. Returns an empty string if the underlying class is 
     * anonymous. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">The simple name of an array is the simple name of the 
     * component type with &quot;[]&quot; appended.  In particular the simple 
     * name of an array whose component type is anonymous is &quot;[]&quot;. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the simple name of the underlying class 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String getSimpleName() { 
        </span><span class="s2">if </span><span class="s1">(isArray()) 
            </span><span class="s2">return </span><span class="s1">getComponentType().getSimpleName()+</span><span class="s6">&quot;[]&quot;</span><span class="s1">; 
 
        String simpleName = getSimpleBinaryName(); 
        </span><span class="s2">if </span><span class="s1">(simpleName == </span><span class="s2">null</span><span class="s1">) { </span><span class="s0">// top level class</span><span class="s1"> 
            simpleName = getName(); 
            </span><span class="s2">return </span><span class="s1">simpleName.substring(simpleName.lastIndexOf(</span><span class="s6">&quot;.&quot;</span><span class="s1">)+</span><span class="s5">1</span><span class="s1">); </span><span class="s0">// strip the package name</span><span class="s1"> 
        } 
        </span><span class="s0">// According to JLS3 &quot;Binary Compatibility&quot; (13.1) the binary</span><span class="s1"> 
        </span><span class="s0">// name of non-package classes (not top level) is the binary</span><span class="s1"> 
        </span><span class="s0">// name of the immediately enclosing class followed by a '$' followed by:</span><span class="s1"> 
        </span><span class="s0">// (for nested and inner classes): the simple name.</span><span class="s1"> 
        </span><span class="s0">// (for local classes): 1 or more digits followed by the simple name.</span><span class="s1"> 
        </span><span class="s0">// (for anonymous classes): 1 or more digits.</span><span class="s1"> 
 
        </span><span class="s0">// Since getSimpleBinaryName() will strip the binary name of</span><span class="s1"> 
        </span><span class="s0">// the immediatly enclosing class, we are now looking at a</span><span class="s1"> 
        </span><span class="s0">// string that matches the regular expression &quot;\$[0-9]*&quot;</span><span class="s1"> 
        </span><span class="s0">// followed by a simple name (considering the simple of an</span><span class="s1"> 
        </span><span class="s0">// anonymous class to be the empty string).</span><span class="s1"> 
 
        </span><span class="s0">// Remove leading &quot;\$[0-9]*&quot; from the name</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">length = simpleName.length(); 
        </span><span class="s2">if </span><span class="s1">(length &lt; </span><span class="s5">1 </span><span class="s1">|| simpleName.charAt(</span><span class="s5">0</span><span class="s1">) != </span><span class="s6">'$'</span><span class="s1">) 
            </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Malformed class name&quot;</span><span class="s1">); 
        </span><span class="s2">int </span><span class="s1">index = </span><span class="s5">1</span><span class="s1">; 
        </span><span class="s2">while </span><span class="s1">(index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index))) 
            index++; 
        </span><span class="s0">// Eventually, this is the empty string iff this is an anonymous class</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">simpleName.substring(index); 
    } 
 
    </span><span class="s0">/** 
     * Return an informative string for the name of this type. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an informative string for the name of this type 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String getTypeName() { 
        </span><span class="s2">if </span><span class="s1">(isArray()) { 
            </span><span class="s2">try </span><span class="s1">{ 
                Class&lt;?&gt; cl = </span><span class="s2">this</span><span class="s1">; 
                </span><span class="s2">int </span><span class="s1">dimensions = </span><span class="s5">0</span><span class="s1">; 
                </span><span class="s2">while </span><span class="s1">(cl.isArray()) { 
                    dimensions++; 
                    cl = cl.getComponentType(); 
                } 
                StringBuilder sb = </span><span class="s2">new </span><span class="s1">StringBuilder(); 
                sb.append(cl.getName()); 
                </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; dimensions; i++) { 
                    sb.append(</span><span class="s6">&quot;[]&quot;</span><span class="s1">); 
                } 
                </span><span class="s2">return </span><span class="s1">sb.toString(); 
            } </span><span class="s2">catch </span><span class="s1">(Throwable e) { </span><span class="s0">/*FALLTHRU*/ </span><span class="s1">} 
        } 
        </span><span class="s2">return </span><span class="s1">getName(); 
    } 
 
    </span><span class="s0">/** 
     * Character.isDigit answers {</span><span class="s3">@code </span><span class="s0">true} to some non-ascii 
     * digits.  This one does not. 
     */</span><span class="s1"> 
    </span><span class="s2">private static boolean </span><span class="s1">isAsciiDigit(</span><span class="s2">char </span><span class="s1">c) { 
        </span><span class="s2">return </span><span class="s6">'0' </span><span class="s1">&lt;= c &amp;&amp; c &lt;= </span><span class="s6">'9'</span><span class="s1">; 
    } 
 
    </span><span class="s0">/** 
     * Returns the canonical name of the underlying class as 
     * defined by the Java Language Specification.  Returns null if 
     * the underlying class does not have a canonical name (i.e., if 
     * it is a local or anonymous class or an array whose component 
     * type does not have a canonical name). 
     * </span><span class="s3">@return </span><span class="s0">the canonical name of the underlying class if it exists, and 
     * {</span><span class="s3">@code </span><span class="s0">null} otherwise. 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">String getCanonicalName() { 
        </span><span class="s2">if </span><span class="s1">(isArray()) { 
            String canonicalName = getComponentType().getCanonicalName(); 
            </span><span class="s2">if </span><span class="s1">(canonicalName != </span><span class="s2">null</span><span class="s1">) 
                </span><span class="s2">return </span><span class="s1">canonicalName + </span><span class="s6">&quot;[]&quot;</span><span class="s1">; 
            </span><span class="s2">else</span><span class="s1"> 
                </span><span class="s2">return null</span><span class="s1">; 
        } 
        </span><span class="s2">if </span><span class="s1">(isLocalOrAnonymousClass()) 
            </span><span class="s2">return null</span><span class="s1">; 
        Class&lt;?&gt; enclosingClass = getEnclosingClass(); 
        </span><span class="s2">if </span><span class="s1">(enclosingClass == </span><span class="s2">null</span><span class="s1">) { </span><span class="s0">// top level class</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">getName(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            String enclosingName = enclosingClass.getCanonicalName(); 
            </span><span class="s2">if </span><span class="s1">(enclosingName == </span><span class="s2">null</span><span class="s1">) 
                </span><span class="s2">return null</span><span class="s1">; 
            </span><span class="s2">return </span><span class="s1">enclosingName + </span><span class="s6">&quot;.&quot; </span><span class="s1">+ getSimpleName(); 
        } 
    } 
 
    </span><span class="s0">/** 
     * Returns {</span><span class="s3">@code </span><span class="s0">true} if and only if the underlying class 
     * is an anonymous class. 
     * 
     * </span><span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if and only if this class is an anonymous class. 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isAnonymousClass() { 
        </span><span class="s2">return </span><span class="s6">&quot;&quot;</span><span class="s1">.equals(getSimpleName()); 
    } 
 
    </span><span class="s0">/** 
     * Returns {</span><span class="s3">@code </span><span class="s0">true} if and only if the underlying class 
     * is a local class. 
     * 
     * </span><span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if and only if this class is a local class. 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isLocalClass() { 
        </span><span class="s2">return </span><span class="s1">isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass(); 
    } 
 
    </span><span class="s0">/** 
     * Returns {</span><span class="s3">@code </span><span class="s0">true} if and only if the underlying class 
     * is a member class. 
     * 
     * </span><span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if and only if this class is a member class. 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isMemberClass() { 
        </span><span class="s2">return </span><span class="s1">getSimpleBinaryName() != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isLocalOrAnonymousClass(); 
    } 
 
    </span><span class="s0">/** 
     * Returns the &quot;simple binary name&quot; of the underlying class, i.e., 
     * the binary name without the leading enclosing class name. 
     * Returns {</span><span class="s3">@code </span><span class="s0">null} if the underlying class is a top level 
     * class. 
     */</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">String getSimpleBinaryName() { 
        Class&lt;?&gt; enclosingClass = getEnclosingClass(); 
        </span><span class="s2">if </span><span class="s1">(enclosingClass == </span><span class="s2">null</span><span class="s1">) </span><span class="s0">// top level class</span><span class="s1"> 
            </span><span class="s2">return null</span><span class="s1">; 
        </span><span class="s0">// Otherwise, strip the enclosing class' name</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">return </span><span class="s1">getName().substring(enclosingClass.getName().length()); 
        } </span><span class="s2">catch </span><span class="s1">(IndexOutOfBoundsException ex) { 
            </span><span class="s2">throw new </span><span class="s1">InternalError(</span><span class="s6">&quot;Malformed class name&quot;</span><span class="s1">, ex); 
        } 
    } 
 
    </span><span class="s0">/** 
     * Returns {</span><span class="s3">@code </span><span class="s0">true} if this is a local class or an anonymous 
     * class.  Returns {</span><span class="s3">@code </span><span class="s0">false} otherwise. 
     */</span><span class="s1"> 
    </span><span class="s2">private boolean </span><span class="s1">isLocalOrAnonymousClass() { 
        </span><span class="s0">// JVM Spec 4.8.6: A class must have an EnclosingMethod</span><span class="s1"> 
        </span><span class="s0">// attribute if and only if it is a local class or an</span><span class="s1"> 
        </span><span class="s0">// anonymous class.</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">getEnclosingMethodInfo() != </span><span class="s2">null</span><span class="s1">; 
    } 
 
    </span><span class="s0">/** 
     * Returns an array containing {</span><span class="s3">@code </span><span class="s0">Class} objects representing all 
     * the public classes and interfaces that are members of the class 
     * represented by this {</span><span class="s3">@code </span><span class="s0">Class} object.  This includes public 
     * class and interface members inherited from superclasses and public class 
     * and interface members declared by the class.  This method returns an 
     * array of length 0 if this {</span><span class="s3">@code </span><span class="s0">Class} object has no public member 
     * classes or interfaces.  This method also returns an array of length 0 if 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object represents a primitive type, an array 
     * class, or void. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Class} objects representing the public 
     *         members of this class 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Class&lt;?&gt;[] getClasses() { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">false</span><span class="s1">); 
 
        </span><span class="s0">// Privileged so this implementation can look at DECLARED classes,</span><span class="s1"> 
        </span><span class="s0">// something the caller might not have privilege to do.  The code here</span><span class="s1"> 
        </span><span class="s0">// is allowed to look at DECLARED classes because (1) it does not hand</span><span class="s1"> 
        </span><span class="s0">// out anything other than public members and (2) public member access</span><span class="s1"> 
        </span><span class="s0">// has already been ok'd by the SecurityManager.</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">java.security.AccessController.doPrivileged( 
            </span><span class="s2">new </span><span class="s1">java.security.PrivilegedAction&lt;Class&lt;?&gt;[]&gt;() { 
                </span><span class="s2">public </span><span class="s1">Class&lt;?&gt;[] run() { 
                    List&lt;Class&lt;?&gt;&gt; list = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;(); 
                    Class&lt;?&gt; currentClass = Class.</span><span class="s2">this</span><span class="s1">; 
                    </span><span class="s2">while </span><span class="s1">(currentClass != </span><span class="s2">null</span><span class="s1">) { 
                        Class&lt;?&gt;[] members = currentClass.getDeclaredClasses(); 
                        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; members.length; i++) { 
                            </span><span class="s2">if </span><span class="s1">(Modifier.isPublic(members[i].getModifiers())) { 
                                list.add(members[i]); 
                            } 
                        } 
                        currentClass = currentClass.getSuperclass(); 
                    } 
                    </span><span class="s2">return </span><span class="s1">list.toArray(</span><span class="s2">new </span><span class="s1">Class&lt;?&gt;[</span><span class="s5">0</span><span class="s1">]); 
                } 
            }); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array containing {</span><span class="s3">@code </span><span class="s0">Field} objects reflecting all 
     * the accessible public fields of the class or interface represented by 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class or interface with no 
     * no accessible public fields, then this method returns an array of length 
     * 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class, then this method 
     * returns the public fields of the class and of all its superclasses. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an interface, then this 
     * method returns the fields of the interface and of all its 
     * superinterfaces. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, a primitive 
     * type, or void, then this method returns an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The elements in the returned array are not sorted and are not in any 
     * particular order. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Field} objects representing the 
     *         public fields 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.3 Field Declarations 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Field[] getFields() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyFields(privateGetPublicFields(</span><span class="s2">null</span><span class="s1">)); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array containing {</span><span class="s3">@code </span><span class="s0">Method} objects reflecting all the 
     * public methods of the class or interface represented by this {</span><span class="s3">@code</span><span class="s0"> 
     * Class} object, including those declared by the class or interface and 
     * those inherited from superclasses and superinterfaces. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a type that has multiple 
     * public methods with the same name and parameter types, but different 
     * return types, then the returned array has a {</span><span class="s3">@code </span><span class="s0">Method} object for 
     * each such method. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a type with a class 
     * initialization method {</span><span class="s3">@code </span><span class="s4">&lt;clinit&gt;</span><span class="s0">}, then the returned array does 
     * </span><span class="s4">&lt;em&gt;</span><span class="s0">not</span><span class="s4">&lt;/em&gt; </span><span class="s0">have a corresponding {</span><span class="s3">@code </span><span class="s0">Method} object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, then the 
     * returned array has a {</span><span class="s3">@code </span><span class="s0">Method} object for each of the public 
     * methods inherited by the array type from {</span><span class="s3">@code </span><span class="s0">Object}. It does not 
     * contain a {</span><span class="s3">@code </span><span class="s0">Method} object for {</span><span class="s3">@code </span><span class="s0">clone()}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an interface then the 
     * returned array does not contain any implicitly declared methods from 
     * {</span><span class="s3">@code </span><span class="s0">Object}. Therefore, if no methods are explicitly declared in 
     * this interface or any of its superinterfaces then the returned array 
     * has length 0. (Note that a {</span><span class="s3">@code </span><span class="s0">Class} object which represents a class 
     * always has public methods, inherited from {</span><span class="s3">@code </span><span class="s0">Object}.) 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a primitive type or void, 
     * then the returned array has length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Static methods declared in superinterfaces of the class or interface 
     * represented by this {</span><span class="s3">@code </span><span class="s0">Class} object are not considered members of 
     * the class or interface. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The elements in the returned array are not sorted and are not in any 
     * particular order. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Method} objects representing the 
     *         public methods of this class 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.4 Method Declarations 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Method[] getMethods() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyMethods(privateGetPublicMethods()); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array containing {</span><span class="s3">@code </span><span class="s0">Constructor} objects reflecting 
     * all the public constructors of the class represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object.  An array of length 0 is returned if the 
     * class has no public constructors, or if the class is an array class, or 
     * if the class reflects a primitive type or void. 
     * 
     * Note that while this method returns an array of {</span><span class="s3">@code</span><span class="s0"> 
     * Constructor</span><span class="s4">&lt;T&gt;</span><span class="s0">} objects (that is an array of constructors from 
     * this class), the return type of this method is {</span><span class="s3">@code</span><span class="s0"> 
     * Constructor</span><span class="s1">&lt;?&gt;</span><span class="s0">[]} and </span><span class="s4">&lt;em&gt;</span><span class="s0">not</span><span class="s4">&lt;/em&gt; </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">Constructor</span><span class="s4">&lt;T&gt;</span><span class="s0">[]} as 
     * might be expected.  This less informative return type is 
     * necessary since after being returned from this method, the 
     * array could be modified to hold {</span><span class="s3">@code </span><span class="s0">Constructor} objects for 
     * different classes, which would violate the type guarantees of 
     * {</span><span class="s3">@code </span><span class="s0">Constructor</span><span class="s4">&lt;T&gt;</span><span class="s0">[]}. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Constructor} objects representing the 
     *         public constructors of this class 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Constructor&lt;?&gt;[] getConstructors() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyConstructors(privateGetDeclaredConstructors(</span><span class="s2">true</span><span class="s1">)); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Field} object that reflects the specified public member 
     * field of the class or interface represented by this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object. The {</span><span class="s3">@code </span><span class="s0">name} parameter is a {</span><span class="s3">@code </span><span class="s0">String} specifying the 
     * simple name of the desired field. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The field to be reflected is determined by the algorithm that 
     * follows.  Let C be the class or interface represented by this object: 
     * 
     * </span><span class="s4">&lt;OL&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;LI&gt; </span><span class="s0">If C declares a public field with the name specified, that is the 
     *      field to be reflected.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;LI&gt; </span><span class="s0">If no field was found in step 1 above, this algorithm is applied 
     *      recursively to each direct superinterface of C. The direct 
     *      superinterfaces are searched in the order they were declared.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;LI&gt; </span><span class="s0">If no field was found in steps 1 and 2 above, and C has a 
     *      superclass S, then this algorithm is invoked recursively upon S. 
     *      If C has no superclass, then a {</span><span class="s3">@code </span><span class="s0">NoSuchFieldException} 
     *      is thrown.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;/OL&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, then this 
     * method does not find the {</span><span class="s3">@code </span><span class="s0">length} field of the array type. 
     * 
     * </span><span class="s3">@param </span><span class="s0">name the field name 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Field} object of this class specified by 
     *         {</span><span class="s3">@code </span><span class="s0">name} 
     * </span><span class="s3">@throws </span><span class="s0">NoSuchFieldException if a field with the specified name is 
     *         not found. 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException if {</span><span class="s3">@code </span><span class="s0">name} is {</span><span class="s3">@code </span><span class="s0">null} 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.3 Field Declarations 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Field getField(String name) 
        </span><span class="s2">throws </span><span class="s1">NoSuchFieldException, SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        Field field = getField0(name); 
        </span><span class="s2">if </span><span class="s1">(field == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">throw new </span><span class="s1">NoSuchFieldException(name); 
        } 
        </span><span class="s2">return </span><span class="s1">field; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Method} object that reflects the specified public 
     * member method of the class or interface represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. The {</span><span class="s3">@code </span><span class="s0">name} parameter is a 
     * {</span><span class="s3">@code </span><span class="s0">String} specifying the simple name of the desired method. The 
     * {</span><span class="s3">@code </span><span class="s0">parameterTypes} parameter is an array of {</span><span class="s3">@code </span><span class="s0">Class} 
     * objects that identify the method's formal parameter types, in declared 
     * order. If {</span><span class="s3">@code </span><span class="s0">parameterTypes} is {</span><span class="s3">@code </span><span class="s0">null}, it is 
     * treated as if it were an empty array. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If the {</span><span class="s3">@code </span><span class="s0">name} is &quot;{</span><span class="s3">@code </span><span class="s4">&lt;init&gt;</span><span class="s0">}&quot; or &quot;{</span><span class="s3">@code </span><span class="s4">&lt;clinit&gt;</span><span class="s0">}&quot; a 
     * {</span><span class="s3">@code </span><span class="s0">NoSuchMethodException} is raised. Otherwise, the method to 
     * be reflected is determined by the algorithm that follows.  Let C be the 
     * class or interface represented by this object: 
     * </span><span class="s4">&lt;OL&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;LI&gt; </span><span class="s0">C is searched for a </span><span class="s4">&lt;I&gt;</span><span class="s0">matching method</span><span class="s4">&lt;/I&gt;</span><span class="s0">, as defined below. If a 
     *      matching method is found, it is reflected.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;LI&gt; </span><span class="s0">If no matching method is found by step 1 then: 
     *   </span><span class="s4">&lt;OL TYPE=&quot;a&quot;&gt;</span><span class="s0"> 
     *   </span><span class="s4">&lt;LI&gt; </span><span class="s0">If C is a class other than {</span><span class="s3">@code </span><span class="s0">Object}, then this algorithm is 
     *        invoked recursively on the superclass of C.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     *   </span><span class="s4">&lt;LI&gt; </span><span class="s0">If C is the class {</span><span class="s3">@code </span><span class="s0">Object}, or if C is an interface, then 
     *        the superinterfaces of C (if any) are searched for a matching 
     *        method. If any such method is found, it is reflected.</span><span class="s4">&lt;/LI&gt;</span><span class="s0"> 
     *   </span><span class="s4">&lt;/OL&gt;&lt;/LI&gt;</span><span class="s0"> 
     * </span><span class="s4">&lt;/OL&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">To find a matching method in a class or interface C:</span><span class="s4">&amp;nbsp; </span><span class="s0">If C 
     * declares exactly one public method with the specified name and exactly 
     * the same formal parameter types, that is the method reflected. If more 
     * than one such method is found in C, and one of these methods has a 
     * return type that is more specific than any of the others, that method is 
     * reflected; otherwise one of the methods is chosen arbitrarily. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">Note that there may be more than one matching method in a 
     * class because while the Java language forbids a class to 
     * declare multiple methods with the same signature but different 
     * return types, the Java virtual machine does not.  This 
     * increased flexibility in the virtual machine can be used to 
     * implement various language features.  For example, covariant 
     * returns can be implemented with {</span><span class="s3">@linkplain</span><span class="s0"> 
     * java.lang.reflect.Method#isBridge bridge methods}; the bridge 
     * method and the method being overridden would have the same 
     * signature but different return types. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, then this 
     * method does not find the {</span><span class="s3">@code </span><span class="s0">clone()} method. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Static methods declared in superinterfaces of the class or interface 
     * represented by this {</span><span class="s3">@code </span><span class="s0">Class} object are not considered members of 
     * the class or interface. 
     * 
     * </span><span class="s3">@param </span><span class="s0">name the name of the method 
     * </span><span class="s3">@param </span><span class="s0">parameterTypes the list of parameters 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Method} object that matches the specified 
     *         {</span><span class="s3">@code </span><span class="s0">name} and {</span><span class="s3">@code </span><span class="s0">parameterTypes} 
     * </span><span class="s3">@throws </span><span class="s0">NoSuchMethodException if a matching method is not found 
     *         or if the name is &quot;</span><span class="s4">&amp;lt;</span><span class="s0">init</span><span class="s4">&amp;gt;</span><span class="s0">&quot;or &quot;</span><span class="s4">&amp;lt;</span><span class="s0">clinit</span><span class="s4">&amp;gt;</span><span class="s0">&quot;. 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException if {</span><span class="s3">@code </span><span class="s0">name} is {</span><span class="s3">@code </span><span class="s0">null} 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.4 Method Declarations 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
        </span><span class="s2">throws </span><span class="s1">NoSuchMethodException, SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        Method method = getMethod0(name, parameterTypes, </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">if </span><span class="s1">(method == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">throw new </span><span class="s1">NoSuchMethodException(getName() + </span><span class="s6">&quot;.&quot; </span><span class="s1">+ name + argumentTypesToString(parameterTypes)); 
        } 
        </span><span class="s2">return </span><span class="s1">method; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Constructor} object that reflects the specified 
     * public constructor of the class represented by this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object. The {</span><span class="s3">@code </span><span class="s0">parameterTypes} parameter is an array of 
     * {</span><span class="s3">@code </span><span class="s0">Class} objects that identify the constructor's formal 
     * parameter types, in declared order. 
     * 
     * If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an inner class 
     * declared in a non-static context, the formal parameter types 
     * include the explicit enclosing instance as the first parameter. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The constructor to reflect is the public constructor of the class 
     * represented by this {</span><span class="s3">@code </span><span class="s0">Class} object whose formal parameter 
     * types match those specified by {</span><span class="s3">@code </span><span class="s0">parameterTypes}. 
     * 
     * </span><span class="s3">@param </span><span class="s0">parameterTypes the parameter array 
     * </span><span class="s3">@return </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Constructor} object of the public constructor that 
     *         matches the specified {</span><span class="s3">@code </span><span class="s0">parameterTypes} 
     * </span><span class="s3">@throws </span><span class="s0">NoSuchMethodException if a matching method is not found. 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and 
     *         the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class. 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
        </span><span class="s2">throws </span><span class="s1">NoSuchMethodException, SecurityException { 
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">getConstructor0(parameterTypes, Member.PUBLIC); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array of {</span><span class="s3">@code </span><span class="s0">Class} objects reflecting all the 
     * classes and interfaces declared as members of the class represented by 
     * this {</span><span class="s3">@code </span><span class="s0">Class} object. This includes public, protected, default 
     * (package) access, and private classes and interfaces declared by the 
     * class, but excludes inherited classes and interfaces.  This method 
     * returns an array of length 0 if the class declares no classes or 
     * interfaces as members, or if this {</span><span class="s3">@code </span><span class="s0">Class} object represents a 
     * primitive type, an array class, or void. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Class} objects representing all the 
     *         declared members of this class 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *         If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *         following conditions is met: 
     * 
     *         </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *         class loader of this class and invocation of 
     *         {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *         s.checkPermission} method with 
     *         {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *         denies access to the declared classes within this class 
     * 
     *         </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *         ancestor of the class loader for the current class and 
     *         invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *         s.checkPackageAccess()} denies access to the package 
     *         of this class 
     * 
     *         </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Class&lt;?&gt;[] getDeclaredClasses() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">false</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">getDeclaredClasses0(); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array of {</span><span class="s3">@code </span><span class="s0">Field} objects reflecting all the fields 
     * declared by the class or interface represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. This includes public, protected, default 
     * (package) access, and private fields, but excludes inherited fields. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class or interface with no 
     * declared fields, then this method returns an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, a primitive 
     * type, or void, then this method returns an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The elements in the returned array are not sorted and are not in any 
     * particular order. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Field} objects representing all the 
     *          declared fields of this class 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared fields within this class 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.3 Field Declarations 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Field[] getDeclaredFields() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyFields(privateGetDeclaredFields(</span><span class="s2">false</span><span class="s1">)); 
    } 
 
 
    </span><span class="s0">/** 
     * 
     * Returns an array containing {</span><span class="s3">@code </span><span class="s0">Method} objects reflecting all the 
     * declared methods of the class or interface represented by this {</span><span class="s3">@code</span><span class="s0"> 
     * Class} object, including public, protected, default (package) 
     * access, and private methods, but excluding inherited methods. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a type that has multiple 
     * declared methods with the same name and parameter types, but different 
     * return types, then the returned array has a {</span><span class="s3">@code </span><span class="s0">Method} object for 
     * each such method. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a type that has a class 
     * initialization method {</span><span class="s3">@code </span><span class="s4">&lt;clinit&gt;</span><span class="s0">}, then the returned array does 
     * </span><span class="s4">&lt;em&gt;</span><span class="s0">not</span><span class="s4">&lt;/em&gt; </span><span class="s0">have a corresponding {</span><span class="s3">@code </span><span class="s0">Method} object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class or interface with no 
     * declared methods, then the returned array has length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, a primitive 
     * type, or void, then the returned array has length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">The elements in the returned array are not sorted and are not in any 
     * particular order. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Method} objects representing all the 
     *          declared methods of this class 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared methods within this class 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.4 Method Declarations 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Method[] getDeclaredMethods() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyMethods(privateGetDeclaredMethods(</span><span class="s2">false</span><span class="s1">)); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns an array of {</span><span class="s3">@code </span><span class="s0">Constructor} objects reflecting all the 
     * constructors declared by the class represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. These are public, protected, default 
     * (package) access, and private constructors.  The elements in the array 
     * returned are not sorted and are not in any particular order.  If the 
     * class has a default constructor, it is included in the returned array. 
     * This method returns an array of length 0 if this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object represents an interface, a primitive type, an array class, or 
     * void. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">See </span><span class="s4">&lt;em&gt;</span><span class="s0">The Java Language Specification</span><span class="s4">&lt;/em&gt;</span><span class="s0">, section 8.2. 
     * 
     * </span><span class="s3">@return  </span><span class="s0">the array of {</span><span class="s3">@code </span><span class="s0">Constructor} objects representing all the 
     *          declared constructors of this class 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared constructors within this class 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Constructor&lt;?&gt;[] getDeclaredConstructors() </span><span class="s2">throws </span><span class="s1">SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">copyConstructors(privateGetDeclaredConstructors(</span><span class="s2">false</span><span class="s1">)); 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Field} object that reflects the specified declared 
     * field of the class or interface represented by this {</span><span class="s3">@code </span><span class="s0">Class} 
     * object. The {</span><span class="s3">@code </span><span class="s0">name} parameter is a {</span><span class="s3">@code </span><span class="s0">String} that specifies 
     * the simple name of the desired field. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, then this 
     * method does not find the {</span><span class="s3">@code </span><span class="s0">length} field of the array type. 
     * 
     * </span><span class="s3">@param </span><span class="s0">name the name of the field 
     * </span><span class="s3">@return  </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Field} object for the specified field in this 
     *          class 
     * </span><span class="s3">@throws  </span><span class="s0">NoSuchFieldException if a field with the specified name is 
     *          not found. 
     * </span><span class="s3">@throws  </span><span class="s0">NullPointerException if {</span><span class="s3">@code </span><span class="s0">name} is {</span><span class="s3">@code </span><span class="s0">null} 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared field 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.3 Field Declarations 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Field getDeclaredField(String name) 
        </span><span class="s2">throws </span><span class="s1">NoSuchFieldException, SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        Field field = searchFields(privateGetDeclaredFields(</span><span class="s2">false</span><span class="s1">), name); 
        </span><span class="s2">if </span><span class="s1">(field == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">throw new </span><span class="s1">NoSuchFieldException(name); 
        } 
        </span><span class="s2">return </span><span class="s1">field; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Method} object that reflects the specified 
     * declared method of the class or interface represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. The {</span><span class="s3">@code </span><span class="s0">name} parameter is a 
     * {</span><span class="s3">@code </span><span class="s0">String} that specifies the simple name of the desired 
     * method, and the {</span><span class="s3">@code </span><span class="s0">parameterTypes} parameter is an array of 
     * {</span><span class="s3">@code </span><span class="s0">Class} objects that identify the method's formal parameter 
     * types, in declared order.  If more than one method with the same 
     * parameter types is declared in a class, and one of these methods has a 
     * return type that is more specific than any of the others, that method is 
     * returned; otherwise one of the methods is chosen arbitrarily.  If the 
     * name is &quot;</span><span class="s4">&amp;lt;</span><span class="s0">init</span><span class="s4">&amp;gt;</span><span class="s0">&quot;or &quot;</span><span class="s4">&amp;lt;</span><span class="s0">clinit</span><span class="s4">&amp;gt;</span><span class="s0">&quot; a {</span><span class="s3">@code </span><span class="s0">NoSuchMethodException} 
     * is raised. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an array type, then this 
     * method does not find the {</span><span class="s3">@code </span><span class="s0">clone()} method. 
     * 
     * </span><span class="s3">@param </span><span class="s0">name the name of the method 
     * </span><span class="s3">@param </span><span class="s0">parameterTypes the parameter array 
     * </span><span class="s3">@return  </span><span class="s0">the {</span><span class="s3">@code </span><span class="s0">Method} object for the method of this class 
     *          matching the specified name and parameters 
     * </span><span class="s3">@throws  </span><span class="s0">NoSuchMethodException if a matching method is not found. 
     * </span><span class="s3">@throws  </span><span class="s0">NullPointerException if {</span><span class="s3">@code </span><span class="s0">name} is {</span><span class="s3">@code </span><span class="s0">null} 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared method 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@jls </span><span class="s0">8.2 Class Members 
     * </span><span class="s3">@jls </span><span class="s0">8.4 Method Declarations 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
        </span><span class="s2">throws </span><span class="s1">NoSuchMethodException, SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        Method method = searchMethods(privateGetDeclaredMethods(</span><span class="s2">false</span><span class="s1">), name, parameterTypes); 
        </span><span class="s2">if </span><span class="s1">(method == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">throw new </span><span class="s1">NoSuchMethodException(getName() + </span><span class="s6">&quot;.&quot; </span><span class="s1">+ name + argumentTypesToString(parameterTypes)); 
        } 
        </span><span class="s2">return </span><span class="s1">method; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns a {</span><span class="s3">@code </span><span class="s0">Constructor} object that reflects the specified 
     * constructor of the class or interface represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object.  The {</span><span class="s3">@code </span><span class="s0">parameterTypes} parameter is 
     * an array of {</span><span class="s3">@code </span><span class="s0">Class} objects that identify the constructor's 
     * formal parameter types, in declared order. 
     * 
     * If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an inner class 
     * declared in a non-static context, the formal parameter types 
     * include the explicit enclosing instance as the first parameter. 
     * 
     * </span><span class="s3">@param </span><span class="s0">parameterTypes the parameter array 
     * </span><span class="s3">@return  </span><span class="s0">The {</span><span class="s3">@code </span><span class="s0">Constructor} object for the constructor with the 
     *          specified parameter list 
     * </span><span class="s3">@throws  </span><span class="s0">NoSuchMethodException if a matching method is not found. 
     * </span><span class="s3">@throws  </span><span class="s0">SecurityException 
     *          If a security manager, </span><span class="s4">&lt;i&gt;</span><span class="s0">s</span><span class="s4">&lt;/i&gt;</span><span class="s0">, is present and any of the 
     *          following conditions is met: 
     * 
     *          </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as the 
     *          class loader of this class and invocation of 
     *          {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPermission 
     *          s.checkPermission} method with 
     *          {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;accessDeclaredMembers&quot;)} 
     *          denies access to the declared constructor 
     * 
     *          </span><span class="s4">&lt;li&gt; </span><span class="s0">the caller's class loader is not the same as or an 
     *          ancestor of the class loader for the current class and 
     *          invocation of {</span><span class="s3">@link </span><span class="s0">SecurityManager#checkPackageAccess 
     *          s.checkPackageAccess()} denies access to the package 
     *          of this class 
     * 
     *          </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@since </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    @CallerSensitive 
    </span><span class="s2">public </span><span class="s1">Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 
        </span><span class="s2">throws </span><span class="s1">NoSuchMethodException, SecurityException { 
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), </span><span class="s2">true</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">getConstructor0(parameterTypes, Member.DECLARED); 
    } 
 
    </span><span class="s0">/** 
     * Finds a resource with a given name.  The rules for searching resources 
     * associated with a given class are implemented by the defining 
     * {</span><span class="s3">@linkplain </span><span class="s0">ClassLoader class loader} of the class.  This method 
     * delegates to this object's class loader.  If this object was loaded by 
     * the bootstrap class loader, the method delegates to {</span><span class="s3">@link</span><span class="s0"> 
     * ClassLoader#getSystemResourceAsStream}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Before delegation, an absolute resource name is constructed from the 
     * given resource name using this algorithm: 
     * 
     * </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;li&gt; </span><span class="s0">If the {</span><span class="s3">@code </span><span class="s0">name} begins with a {</span><span class="s3">@code </span><span class="s0">'/'} 
     * (</span><span class="s4">&lt;tt&gt;</span><span class="s0">'</span><span class="s4">&amp;#92;</span><span class="s0">u002f'</span><span class="s4">&lt;/tt&gt;</span><span class="s0">), then the absolute name of the resource is the 
     * portion of the {</span><span class="s3">@code </span><span class="s0">name} following the {</span><span class="s3">@code </span><span class="s0">'/'}. 
     * 
     * </span><span class="s4">&lt;li&gt; </span><span class="s0">Otherwise, the absolute name is of the following form: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *   {</span><span class="s3">@code </span><span class="s0">modified_package_name/name} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Where the {</span><span class="s3">@code </span><span class="s0">modified_package_name} is the package name of this 
     * object with {</span><span class="s3">@code </span><span class="s0">'/'} substituted for {</span><span class="s3">@code </span><span class="s0">'.'} 
     * (</span><span class="s4">&lt;tt&gt;</span><span class="s0">'</span><span class="s4">&amp;#92;</span><span class="s0">u002e'</span><span class="s4">&lt;/tt&gt;</span><span class="s0">). 
     * 
     * </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@param  </span><span class="s0">name name of the desired resource 
     * </span><span class="s3">@return      </span><span class="s0">A {</span><span class="s3">@link </span><span class="s0">java.io.InputStream} object or {</span><span class="s3">@code </span><span class="s0">null} if 
     *              no resource with this name is found 
     * </span><span class="s3">@throws  </span><span class="s0">NullPointerException If {</span><span class="s3">@code </span><span class="s0">name} is {</span><span class="s3">@code </span><span class="s0">null} 
     * </span><span class="s3">@since  </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
     </span><span class="s2">public </span><span class="s1">InputStream getResourceAsStream(String name) { 
        name = resolveName(name); 
        ClassLoader cl = getClassLoader0(); 
        </span><span class="s2">if </span><span class="s1">(cl==</span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// A system class.</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ClassLoader.getSystemResourceAsStream(name); 
        } 
        </span><span class="s2">return </span><span class="s1">cl.getResourceAsStream(name); 
    } 
 
    </span><span class="s0">/** 
     * Finds a resource with a given name.  The rules for searching resources 
     * associated with a given class are implemented by the defining 
     * {</span><span class="s3">@linkplain </span><span class="s0">ClassLoader class loader} of the class.  This method 
     * delegates to this object's class loader.  If this object was loaded by 
     * the bootstrap class loader, the method delegates to {</span><span class="s3">@link</span><span class="s0"> 
     * ClassLoader#getSystemResource}. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Before delegation, an absolute resource name is constructed from the 
     * given resource name using this algorithm: 
     * 
     * </span><span class="s4">&lt;ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;li&gt; </span><span class="s0">If the {</span><span class="s3">@code </span><span class="s0">name} begins with a {</span><span class="s3">@code </span><span class="s0">'/'} 
     * (</span><span class="s4">&lt;tt&gt;</span><span class="s0">'</span><span class="s4">&amp;#92;</span><span class="s0">u002f'</span><span class="s4">&lt;/tt&gt;</span><span class="s0">), then the absolute name of the resource is the 
     * portion of the {</span><span class="s3">@code </span><span class="s0">name} following the {</span><span class="s3">@code </span><span class="s0">'/'}. 
     * 
     * </span><span class="s4">&lt;li&gt; </span><span class="s0">Otherwise, the absolute name is of the following form: 
     * 
     * </span><span class="s4">&lt;blockquote&gt;</span><span class="s0"> 
     *   {</span><span class="s3">@code </span><span class="s0">modified_package_name/name} 
     * </span><span class="s4">&lt;/blockquote&gt;</span><span class="s0"> 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">Where the {</span><span class="s3">@code </span><span class="s0">modified_package_name} is the package name of this 
     * object with {</span><span class="s3">@code </span><span class="s0">'/'} substituted for {</span><span class="s3">@code </span><span class="s0">'.'} 
     * (</span><span class="s4">&lt;tt&gt;</span><span class="s0">'</span><span class="s4">&amp;#92;</span><span class="s0">u002e'</span><span class="s4">&lt;/tt&gt;</span><span class="s0">). 
     * 
     * </span><span class="s4">&lt;/ul&gt;</span><span class="s0"> 
     * 
     * </span><span class="s3">@param  </span><span class="s0">name name of the desired resource 
     * </span><span class="s3">@return      </span><span class="s0">A  {</span><span class="s3">@link </span><span class="s0">java.net.URL} object or {</span><span class="s3">@code </span><span class="s0">null} if no 
     *              resource with this name is found 
     * </span><span class="s3">@since  </span><span class="s0">JDK1.1 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">java.net.URL getResource(String name) { 
        name = resolveName(name); 
        ClassLoader cl = getClassLoader0(); 
        </span><span class="s2">if </span><span class="s1">(cl==</span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// A system class.</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ClassLoader.getSystemResource(name); 
        } 
        </span><span class="s2">return </span><span class="s1">cl.getResource(name); 
    } 
 
 
 
    </span><span class="s0">/** protection domain returned when the internal domain is null */</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">java.security.ProtectionDomain allPermDomain; 
 
 
    </span><span class="s0">/** 
     * Returns the {</span><span class="s3">@code </span><span class="s0">ProtectionDomain} of this class.  If there is a 
     * security manager installed, this method first calls the security 
     * manager's {</span><span class="s3">@code </span><span class="s0">checkPermission} method with a 
     * {</span><span class="s3">@code </span><span class="s0">RuntimePermission(&quot;getProtectionDomain&quot;)} permission to 
     * ensure it's ok to get the 
     * {</span><span class="s3">@code </span><span class="s0">ProtectionDomain}. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the ProtectionDomain of this class 
     * 
     * </span><span class="s3">@throws </span><span class="s0">SecurityException 
     *        if a security manager exists and its 
     *        {</span><span class="s3">@code </span><span class="s0">checkPermission} method doesn't allow 
     *        getting the ProtectionDomain. 
     * 
     * </span><span class="s3">@see </span><span class="s0">java.security.ProtectionDomain 
     * </span><span class="s3">@see </span><span class="s0">SecurityManager#checkPermission 
     * </span><span class="s3">@see </span><span class="s0">java.lang.RuntimePermission 
     * </span><span class="s3">@since </span><span class="s0">1.2 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">java.security.ProtectionDomain getProtectionDomain() { 
        SecurityManager sm = System.getSecurityManager(); 
        </span><span class="s2">if </span><span class="s1">(sm != </span><span class="s2">null</span><span class="s1">) { 
            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION); 
        } 
        java.security.ProtectionDomain pd = getProtectionDomain0(); 
        </span><span class="s2">if </span><span class="s1">(pd == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(allPermDomain == </span><span class="s2">null</span><span class="s1">) { 
                java.security.Permissions perms = 
                    </span><span class="s2">new </span><span class="s1">java.security.Permissions(); 
                perms.add(SecurityConstants.ALL_PERMISSION); 
                allPermDomain = 
                    </span><span class="s2">new </span><span class="s1">java.security.ProtectionDomain(</span><span class="s2">null</span><span class="s1">, perms); 
            } 
            pd = allPermDomain; 
        } 
        </span><span class="s2">return </span><span class="s1">pd; 
    } 
 
 
    </span><span class="s0">/** 
     * Returns the ProtectionDomain of this class. 
     */</span><span class="s1"> 
    </span><span class="s2">private native </span><span class="s1">java.security.ProtectionDomain getProtectionDomain0(); 
 
    </span><span class="s0">/* 
     * Return the Virtual Machine's Class object for the named 
     * primitive type. 
     */</span><span class="s1"> 
    </span><span class="s2">static native </span><span class="s1">Class&lt;?&gt; getPrimitiveClass(String name); 
 
    </span><span class="s0">/* 
     * Check if client is allowed to access members.  If access is denied, 
     * throw a SecurityException. 
     * 
     * This method also enforces package access. 
     * 
     * &lt;p&gt; Default policy: allow all clients access with normal Java access 
     * control. 
     */</span><span class="s1"> 
    </span><span class="s2">private void </span><span class="s1">checkMemberAccess(</span><span class="s2">int </span><span class="s1">which, Class&lt;?&gt; caller, </span><span class="s2">boolean </span><span class="s1">checkProxyInterfaces) { 
        </span><span class="s2">final </span><span class="s1">SecurityManager s = System.getSecurityManager(); 
        </span><span class="s2">if </span><span class="s1">(s != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">/* Default policy allows access to all {@link Member#PUBLIC} members, 
             * as well as access to classes that have the same class loader as the caller. 
             * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;) 
             * permission. 
             */</span><span class="s1"> 
            </span><span class="s2">final </span><span class="s1">ClassLoader ccl = ClassLoader.getClassLoader(caller); 
            </span><span class="s2">final </span><span class="s1">ClassLoader cl = getClassLoader0(); 
            </span><span class="s2">if </span><span class="s1">(which != Member.PUBLIC) { 
                </span><span class="s2">if </span><span class="s1">(ccl != cl) { 
                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION); 
                } 
            } 
            </span><span class="s2">this</span><span class="s1">.checkPackageAccess(ccl, checkProxyInterfaces); 
        } 
    } 
 
    </span><span class="s0">/* 
     * Checks if a client loaded in ClassLoader ccl is allowed to access this 
     * class under the current package access policy. If access is denied, 
     * throw a SecurityException. 
     */</span><span class="s1"> 
    </span><span class="s2">private void </span><span class="s1">checkPackageAccess(</span><span class="s2">final </span><span class="s1">ClassLoader ccl, </span><span class="s2">boolean </span><span class="s1">checkProxyInterfaces) { 
        </span><span class="s2">final </span><span class="s1">SecurityManager s = System.getSecurityManager(); 
        </span><span class="s2">if </span><span class="s1">(s != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">final </span><span class="s1">ClassLoader cl = getClassLoader0(); 
 
            </span><span class="s2">if </span><span class="s1">(ReflectUtil.needsPackageAccessCheck(ccl, cl)) { 
                String name = </span><span class="s2">this</span><span class="s1">.getName(); 
                </span><span class="s2">int </span><span class="s1">i = name.lastIndexOf(</span><span class="s6">'.'</span><span class="s1">); 
                </span><span class="s2">if </span><span class="s1">(i != -</span><span class="s5">1</span><span class="s1">) { 
                    </span><span class="s0">// skip the package access check on a proxy class in default proxy package</span><span class="s1"> 
                    String pkg = name.substring(</span><span class="s5">0</span><span class="s1">, i); 
                    </span><span class="s2">if </span><span class="s1">(!Proxy.isProxyClass(</span><span class="s2">this</span><span class="s1">) || ReflectUtil.isNonPublicProxyClass(</span><span class="s2">this</span><span class="s1">)) { 
                        s.checkPackageAccess(pkg); 
                    } 
                } 
            } 
            </span><span class="s0">// check package access on the proxy interfaces</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">(checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(</span><span class="s2">this</span><span class="s1">)) { 
                ReflectUtil.checkProxyPackageAccess(ccl, </span><span class="s2">this</span><span class="s1">.getInterfaces()); 
            } 
        } 
    } 
 
    </span><span class="s0">/** 
     * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot; 
     * if name is absolute 
     */</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">String resolveName(String name) { 
        </span><span class="s2">if </span><span class="s1">(name == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">name; 
        } 
        </span><span class="s2">if </span><span class="s1">(!name.startsWith(</span><span class="s6">&quot;/&quot;</span><span class="s1">)) { 
            Class&lt;?&gt; c = </span><span class="s2">this</span><span class="s1">; 
            </span><span class="s2">while </span><span class="s1">(c.isArray()) { 
                c = c.getComponentType(); 
            } 
            String baseName = c.getName(); 
            </span><span class="s2">int </span><span class="s1">index = baseName.lastIndexOf(</span><span class="s6">'.'</span><span class="s1">); 
            </span><span class="s2">if </span><span class="s1">(index != -</span><span class="s5">1</span><span class="s1">) { 
                name = baseName.substring(</span><span class="s5">0</span><span class="s1">, index).replace(</span><span class="s6">'.'</span><span class="s1">, </span><span class="s6">'/'</span><span class="s1">) 
                    +</span><span class="s6">&quot;/&quot;</span><span class="s1">+name; 
            } 
        } </span><span class="s2">else </span><span class="s1">{ 
            name = name.substring(</span><span class="s5">1</span><span class="s1">); 
        } 
        </span><span class="s2">return </span><span class="s1">name; 
    } 
 
    </span><span class="s0">/** 
     * Atomic operations support. 
     */</span><span class="s1"> 
    </span><span class="s2">private static class </span><span class="s1">Atomic { 
        </span><span class="s0">// initialize Unsafe machinery here, since we need to call Class.class instance method</span><span class="s1"> 
        </span><span class="s0">// and have to avoid calling it in the static initializer of the Class class...</span><span class="s1"> 
        </span><span class="s2">private static final </span><span class="s1">Unsafe unsafe = Unsafe.getUnsafe(); 
        </span><span class="s0">// offset of Class.reflectionData instance field</span><span class="s1"> 
        </span><span class="s2">private static final long </span><span class="s1">reflectionDataOffset; 
        </span><span class="s0">// offset of Class.annotationType instance field</span><span class="s1"> 
        </span><span class="s2">private static final long </span><span class="s1">annotationTypeOffset; 
        </span><span class="s0">// offset of Class.annotationData instance field</span><span class="s1"> 
        </span><span class="s2">private static final long </span><span class="s1">annotationDataOffset; 
 
        </span><span class="s2">static </span><span class="s1">{ 
            Field[] fields = Class.</span><span class="s2">class</span><span class="s1">.getDeclaredFields0(</span><span class="s2">false</span><span class="s1">); </span><span class="s0">// bypass caches</span><span class="s1"> 
            reflectionDataOffset = objectFieldOffset(fields, </span><span class="s6">&quot;reflectionData&quot;</span><span class="s1">); 
            annotationTypeOffset = objectFieldOffset(fields, </span><span class="s6">&quot;annotationType&quot;</span><span class="s1">); 
            annotationDataOffset = objectFieldOffset(fields, </span><span class="s6">&quot;annotationData&quot;</span><span class="s1">); 
        } 
 
        </span><span class="s2">private static long </span><span class="s1">objectFieldOffset(Field[] fields, String fieldName) { 
            Field field = searchFields(fields, fieldName); 
            </span><span class="s2">if </span><span class="s1">(field == </span><span class="s2">null</span><span class="s1">) { 
                </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s6">&quot;No &quot; </span><span class="s1">+ fieldName + </span><span class="s6">&quot; field found in java.lang.Class&quot;</span><span class="s1">); 
            } 
            </span><span class="s2">return </span><span class="s1">unsafe.objectFieldOffset(field); 
        } 
 
        </span><span class="s2">static </span><span class="s1">&lt;T&gt; </span><span class="s2">boolean </span><span class="s1">casReflectionData(Class&lt;?&gt; clazz, 
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData, 
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) { 
            </span><span class="s2">return </span><span class="s1">unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData); 
        } 
 
        </span><span class="s2">static </span><span class="s1">&lt;T&gt; </span><span class="s2">boolean </span><span class="s1">casAnnotationType(Class&lt;?&gt; clazz, 
                                             AnnotationType oldType, 
                                             AnnotationType newType) { 
            </span><span class="s2">return </span><span class="s1">unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType); 
        } 
 
        </span><span class="s2">static </span><span class="s1">&lt;T&gt; </span><span class="s2">boolean </span><span class="s1">casAnnotationData(Class&lt;?&gt; clazz, 
                                             AnnotationData oldData, 
                                             AnnotationData newData) { 
            </span><span class="s2">return </span><span class="s1">unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData); 
        } 
    } 
 
    </span><span class="s0">/** 
     * Reflection support. 
     */</span><span class="s1"> 
 
    </span><span class="s0">// Caches for certain reflective results</span><span class="s1"> 
    </span><span class="s2">private static boolean </span><span class="s1">useCaches = </span><span class="s2">true</span><span class="s1">; 
 
    </span><span class="s0">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span><span class="s1"> 
    </span><span class="s2">private static class </span><span class="s1">ReflectionData&lt;T&gt; { 
        </span><span class="s2">volatile </span><span class="s1">Field[] declaredFields; 
        </span><span class="s2">volatile </span><span class="s1">Field[] publicFields; 
        </span><span class="s2">volatile </span><span class="s1">Method[] declaredMethods; 
        </span><span class="s2">volatile </span><span class="s1">Method[] publicMethods; 
        </span><span class="s2">volatile </span><span class="s1">Constructor&lt;T&gt;[] declaredConstructors; 
        </span><span class="s2">volatile </span><span class="s1">Constructor&lt;T&gt;[] publicConstructors; 
        </span><span class="s0">// Intermediate results for getFields and getMethods</span><span class="s1"> 
        </span><span class="s2">volatile </span><span class="s1">Field[] declaredPublicFields; 
        </span><span class="s2">volatile </span><span class="s1">Method[] declaredPublicMethods; 
        </span><span class="s2">volatile </span><span class="s1">Class&lt;?&gt;[] interfaces; 
 
        </span><span class="s0">// Value of classRedefinedCount when we created this ReflectionData instance</span><span class="s1"> 
        </span><span class="s2">final int </span><span class="s1">redefinedCount; 
 
        ReflectionData(</span><span class="s2">int </span><span class="s1">redefinedCount) { 
            </span><span class="s2">this</span><span class="s1">.redefinedCount = redefinedCount; 
        } 
    } 
 
    </span><span class="s2">private volatile transient </span><span class="s1">SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData; 
 
    </span><span class="s0">// Incremented by the VM on each call to JVM TI RedefineClasses()</span><span class="s1"> 
    </span><span class="s0">// that redefines this class or a superclass.</span><span class="s1"> 
    </span><span class="s2">private volatile transient int </span><span class="s1">classRedefinedCount = </span><span class="s5">0</span><span class="s1">; 
 
    </span><span class="s0">// Lazily create and cache ReflectionData</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">ReflectionData&lt;T&gt; reflectionData() { 
        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = </span><span class="s2">this</span><span class="s1">.reflectionData; 
        </span><span class="s2">int </span><span class="s1">classRedefinedCount = </span><span class="s2">this</span><span class="s1">.classRedefinedCount; 
        ReflectionData&lt;T&gt; rd; 
        </span><span class="s2">if </span><span class="s1">(useCaches &amp;&amp; 
            reflectionData != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
            (rd = reflectionData.get()) != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
            rd.redefinedCount == classRedefinedCount) { 
            </span><span class="s2">return </span><span class="s1">rd; 
        } 
        </span><span class="s0">// else no SoftReference or cleared SoftReference or stale ReflectionData</span><span class="s1"> 
        </span><span class="s0">// -&gt; create and replace new instance</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">newReflectionData(reflectionData, classRedefinedCount); 
    } 
 
    </span><span class="s2">private </span><span class="s1">ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData, 
                                                </span><span class="s2">int </span><span class="s1">classRedefinedCount) { 
        </span><span class="s2">if </span><span class="s1">(!useCaches) </span><span class="s2">return null</span><span class="s1">; 
 
        </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) { 
            ReflectionData&lt;T&gt; rd = </span><span class="s2">new </span><span class="s1">ReflectionData&lt;&gt;(classRedefinedCount); 
            </span><span class="s0">// try to CAS it...</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">(Atomic.casReflectionData(</span><span class="s2">this</span><span class="s1">, oldReflectionData, </span><span class="s2">new </span><span class="s1">SoftReference&lt;&gt;(rd))) { 
                </span><span class="s2">return </span><span class="s1">rd; 
            } 
            </span><span class="s0">// else retry</span><span class="s1"> 
            oldReflectionData = </span><span class="s2">this</span><span class="s1">.reflectionData; 
            classRedefinedCount = </span><span class="s2">this</span><span class="s1">.classRedefinedCount; 
            </span><span class="s2">if </span><span class="s1">(oldReflectionData != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
                (rd = oldReflectionData.get()) != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
                rd.redefinedCount == classRedefinedCount) { 
                </span><span class="s2">return </span><span class="s1">rd; 
            } 
        } 
    } 
 
    </span><span class="s0">// Generic signature handling</span><span class="s1"> 
    </span><span class="s2">private native </span><span class="s1">String getGenericSignature0(); 
 
    </span><span class="s0">// Generic info repository; lazily initialized</span><span class="s1"> 
    </span><span class="s2">private volatile transient </span><span class="s1">ClassRepository genericInfo; 
 
    </span><span class="s0">// accessor for factory</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">GenericsFactory getFactory() { 
        </span><span class="s0">// create scope and factory</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">CoreReflectionFactory.make(</span><span class="s2">this</span><span class="s1">, ClassScope.make(</span><span class="s2">this</span><span class="s1">)); 
    } 
 
    </span><span class="s0">// accessor for generic info repository;</span><span class="s1"> 
    </span><span class="s0">// generic info is lazily initialized</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">ClassRepository getGenericInfo() { 
        ClassRepository genericInfo = </span><span class="s2">this</span><span class="s1">.genericInfo; 
        </span><span class="s2">if </span><span class="s1">(genericInfo == </span><span class="s2">null</span><span class="s1">) { 
            String signature = getGenericSignature0(); 
            </span><span class="s2">if </span><span class="s1">(signature == </span><span class="s2">null</span><span class="s1">) { 
                genericInfo = ClassRepository.NONE; 
            } </span><span class="s2">else </span><span class="s1">{ 
                genericInfo = ClassRepository.make(signature, getFactory()); 
            } 
            </span><span class="s2">this</span><span class="s1">.genericInfo = genericInfo; 
        } 
        </span><span class="s2">return </span><span class="s1">(genericInfo != ClassRepository.NONE) ? genericInfo : </span><span class="s2">null</span><span class="s1">; 
    } 
 
    </span><span class="s0">// Annotations handling</span><span class="s1"> 
    </span><span class="s2">native byte</span><span class="s1">[] getRawAnnotations(); 
    </span><span class="s0">// Since 1.8</span><span class="s1"> 
    </span><span class="s2">native byte</span><span class="s1">[] getRawTypeAnnotations(); 
    </span><span class="s2">static byte</span><span class="s1">[] getExecutableTypeAnnotationBytes(Executable ex) { 
        </span><span class="s2">return </span><span class="s1">getReflectionFactory().getExecutableTypeAnnotationBytes(ex); 
    } 
 
    </span><span class="s2">native </span><span class="s1">ConstantPool getConstantPool(); 
 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">// java.lang.reflect.Field handling</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
 
    </span><span class="s0">// Returns an array of &quot;root&quot; fields. These Field objects must NOT</span><span class="s1"> 
    </span><span class="s0">// be propagated to the outside world, but must instead be copied</span><span class="s1"> 
    </span><span class="s0">// via ReflectionFactory.copyField.</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Field[] privateGetDeclaredFields(</span><span class="s2">boolean </span><span class="s1">publicOnly) { 
        checkInitted(); 
        Field[] res; 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields; 
            </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; 
        } 
        </span><span class="s0">// No cached value available; request value from VM</span><span class="s1"> 
        res = Reflection.filterFields(</span><span class="s2">this</span><span class="s1">, getDeclaredFields0(publicOnly)); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(publicOnly) { 
                rd.declaredPublicFields = res; 
            } </span><span class="s2">else </span><span class="s1">{ 
                rd.declaredFields = res; 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">res; 
    } 
 
    </span><span class="s0">// Returns an array of &quot;root&quot; fields. These Field objects must NOT</span><span class="s1"> 
    </span><span class="s0">// be propagated to the outside world, but must instead be copied</span><span class="s1"> 
    </span><span class="s0">// via ReflectionFactory.copyField.</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) { 
        checkInitted(); 
        Field[] res; 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            res = rd.publicFields; 
            </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; 
        } 
 
        </span><span class="s0">// No cached value available; compute value recursively.</span><span class="s1"> 
        </span><span class="s0">// Traverse in correct order for getField().</span><span class="s1"> 
        List&lt;Field&gt; fields = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;(); 
        </span><span class="s2">if </span><span class="s1">(traversedInterfaces == </span><span class="s2">null</span><span class="s1">) { 
            traversedInterfaces = </span><span class="s2">new </span><span class="s1">HashSet&lt;&gt;(); 
        } 
 
        </span><span class="s0">// Local fields</span><span class="s1"> 
        Field[] tmp = privateGetDeclaredFields(</span><span class="s2">true</span><span class="s1">); 
        addAll(fields, tmp); 
 
        </span><span class="s0">// Direct superinterfaces, recursively</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">(Class&lt;?&gt; c : getInterfaces()) { 
            </span><span class="s2">if </span><span class="s1">(!traversedInterfaces.contains(c)) { 
                traversedInterfaces.add(c); 
                addAll(fields, c.privateGetPublicFields(traversedInterfaces)); 
            } 
        } 
 
        </span><span class="s0">// Direct superclass, recursively</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(!isInterface()) { 
            Class&lt;?&gt; c = getSuperclass(); 
            </span><span class="s2">if </span><span class="s1">(c != </span><span class="s2">null</span><span class="s1">) { 
                addAll(fields, c.privateGetPublicFields(traversedInterfaces)); 
            } 
        } 
 
        res = </span><span class="s2">new </span><span class="s1">Field[fields.size()]; 
        fields.toArray(res); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            rd.publicFields = res; 
        } 
        </span><span class="s2">return </span><span class="s1">res; 
    } 
 
    </span><span class="s2">private static void </span><span class="s1">addAll(Collection&lt;Field&gt; c, Field[] o) { 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; o.length; i++) { 
            c.add(o[i]); 
        } 
    } 
 
 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">// java.lang.reflect.Constructor handling</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
 
    </span><span class="s0">// Returns an array of &quot;root&quot; constructors. These Constructor</span><span class="s1"> 
    </span><span class="s0">// objects must NOT be propagated to the outside world, but must</span><span class="s1"> 
    </span><span class="s0">// instead be copied via ReflectionFactory.copyConstructor.</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Constructor&lt;T&gt;[] privateGetDeclaredConstructors(</span><span class="s2">boolean </span><span class="s1">publicOnly) { 
        checkInitted(); 
        Constructor&lt;T&gt;[] res; 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors; 
            </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; 
        } 
        </span><span class="s0">// No cached value available; request value from VM</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(isInterface()) { 
            @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) </span><span class="s2">new </span><span class="s1">Constructor&lt;?&gt;[</span><span class="s5">0</span><span class="s1">]; 
            res = temporaryRes; 
        } </span><span class="s2">else </span><span class="s1">{ 
            res = getDeclaredConstructors0(publicOnly); 
        } 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(publicOnly) { 
                rd.publicConstructors = res; 
            } </span><span class="s2">else </span><span class="s1">{ 
                rd.declaredConstructors = res; 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">res; 
    } 
 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">// java.lang.reflect.Method handling</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
 
    </span><span class="s0">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span><span class="s1"> 
    </span><span class="s0">// be propagated to the outside world, but must instead be copied</span><span class="s1"> 
    </span><span class="s0">// via ReflectionFactory.copyMethod.</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Method[] privateGetDeclaredMethods(</span><span class="s2">boolean </span><span class="s1">publicOnly) { 
        checkInitted(); 
        Method[] res; 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods; 
            </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; 
        } 
        </span><span class="s0">// No cached value available; request value from VM</span><span class="s1"> 
        res = Reflection.filterMethods(</span><span class="s2">this</span><span class="s1">, getDeclaredMethods0(publicOnly)); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(publicOnly) { 
                rd.declaredPublicMethods = res; 
            } </span><span class="s2">else </span><span class="s1">{ 
                rd.declaredMethods = res; 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">res; 
    } 
 
    </span><span class="s2">static class </span><span class="s1">MethodArray { 
        </span><span class="s0">// Don't add or remove methods except by add() or remove() calls.</span><span class="s1"> 
        </span><span class="s2">private </span><span class="s1">Method[] methods; 
        </span><span class="s2">private int </span><span class="s1">length; 
        </span><span class="s2">private int </span><span class="s1">defaults; 
 
        MethodArray() { 
            </span><span class="s2">this</span><span class="s1">(</span><span class="s5">20</span><span class="s1">); 
        } 
 
        MethodArray(</span><span class="s2">int </span><span class="s1">initialSize) { 
            </span><span class="s2">if </span><span class="s1">(initialSize &lt; </span><span class="s5">2</span><span class="s1">) 
                </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s6">&quot;Size should be 2 or more&quot;</span><span class="s1">); 
 
            methods = </span><span class="s2">new </span><span class="s1">Method[initialSize]; 
            length = </span><span class="s5">0</span><span class="s1">; 
            defaults = </span><span class="s5">0</span><span class="s1">; 
        } 
 
        </span><span class="s2">boolean </span><span class="s1">hasDefaults() { 
            </span><span class="s2">return </span><span class="s1">defaults != </span><span class="s5">0</span><span class="s1">; 
        } 
 
        </span><span class="s2">void </span><span class="s1">add(Method m) { 
            </span><span class="s2">if </span><span class="s1">(length == methods.length) { 
                methods = Arrays.copyOf(methods, </span><span class="s5">2 </span><span class="s1">* methods.length); 
            } 
            methods[length++] = m; 
 
            </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null </span><span class="s1">&amp;&amp; m.isDefault()) 
                defaults++; 
        } 
 
        </span><span class="s2">void </span><span class="s1">addAll(Method[] ma) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; ma.length; i++) { 
                add(ma[i]); 
            } 
        } 
 
        </span><span class="s2">void </span><span class="s1">addAll(MethodArray ma) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; ma.length(); i++) { 
                add(ma.get(i)); 
            } 
        } 
 
        </span><span class="s2">void </span><span class="s1">addIfNotPresent(Method newMethod) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; length; i++) { 
                Method m = methods[i]; 
                </span><span class="s2">if </span><span class="s1">(m == newMethod || (m != </span><span class="s2">null </span><span class="s1">&amp;&amp; m.equals(newMethod))) { 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
            } 
            add(newMethod); 
        } 
 
        </span><span class="s2">void </span><span class="s1">addAllIfNotPresent(MethodArray newMethods) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; newMethods.length(); i++) { 
                Method m = newMethods.get(i); 
                </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null</span><span class="s1">) { 
                    addIfNotPresent(m); 
                } 
            } 
        } 
 
        </span><span class="s0">/* Add Methods declared in an interface to this MethodArray. 
         * Static methods declared in interfaces are not inherited. 
         */</span><span class="s1"> 
        </span><span class="s2">void </span><span class="s1">addInterfaceMethods(Method[] methods) { 
            </span><span class="s2">for </span><span class="s1">(Method candidate : methods) { 
                </span><span class="s2">if </span><span class="s1">(!Modifier.isStatic(candidate.getModifiers())) { 
                    add(candidate); 
                } 
            } 
        } 
 
        </span><span class="s2">int </span><span class="s1">length() { 
            </span><span class="s2">return </span><span class="s1">length; 
        } 
 
        Method get(</span><span class="s2">int </span><span class="s1">i) { 
            </span><span class="s2">return </span><span class="s1">methods[i]; 
        } 
 
        Method getFirst() { 
            </span><span class="s2">for </span><span class="s1">(Method m : methods) 
                </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null</span><span class="s1">) 
                    </span><span class="s2">return </span><span class="s1">m; 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
 
        </span><span class="s2">void </span><span class="s1">removeByNameAndDescriptor(Method toRemove) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; length; i++) { 
                Method m = methods[i]; 
                </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null </span><span class="s1">&amp;&amp; matchesNameAndDescriptor(m, toRemove)) { 
                    remove(i); 
                } 
            } 
        } 
 
        </span><span class="s2">private void </span><span class="s1">remove(</span><span class="s2">int </span><span class="s1">i) { 
            </span><span class="s2">if </span><span class="s1">(methods[i] != </span><span class="s2">null </span><span class="s1">&amp;&amp; methods[i].isDefault()) 
                defaults--; 
            methods[i] = </span><span class="s2">null</span><span class="s1">; 
        } 
 
        </span><span class="s2">private boolean </span><span class="s1">matchesNameAndDescriptor(Method m1, Method m2) { 
            </span><span class="s2">return </span><span class="s1">m1.getReturnType() == m2.getReturnType() &amp;&amp; 
                   m1.getName() == m2.getName() &amp;&amp; </span><span class="s0">// name is guaranteed to be interned</span><span class="s1"> 
                   arrayContentsEq(m1.getParameterTypes(), 
                           m2.getParameterTypes()); 
        } 
 
        </span><span class="s2">void </span><span class="s1">compactAndTrim() { 
            </span><span class="s2">int </span><span class="s1">newPos = </span><span class="s5">0</span><span class="s1">; 
            </span><span class="s0">// Get rid of null slots</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">pos = </span><span class="s5">0</span><span class="s1">; pos &lt; length; pos++) { 
                Method m = methods[pos]; 
                </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null</span><span class="s1">) { 
                    </span><span class="s2">if </span><span class="s1">(pos != newPos) { 
                        methods[newPos] = m; 
                    } 
                    newPos++; 
                } 
            } 
            </span><span class="s2">if </span><span class="s1">(newPos != methods.length) { 
                methods = Arrays.copyOf(methods, newPos); 
            } 
        } 
 
        </span><span class="s0">/* Removes all Methods from this MethodArray that have a more specific 
         * default Method in this MethodArray. 
         * 
         * Users of MethodArray are responsible for pruning Methods that have 
         * a more specific &lt;em&gt;concrete&lt;/em&gt; Method. 
         */</span><span class="s1"> 
        </span><span class="s2">void </span><span class="s1">removeLessSpecifics() { 
            </span><span class="s2">if </span><span class="s1">(!hasDefaults()) 
                </span><span class="s2">return</span><span class="s1">; 
 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; length; i++) { 
                Method m = get(i); 
                </span><span class="s2">if  </span><span class="s1">(m == </span><span class="s2">null </span><span class="s1">|| !m.isDefault()) 
                    </span><span class="s2">continue</span><span class="s1">; 
 
                </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">j  = </span><span class="s5">0</span><span class="s1">; j &lt; length; j++) { 
                    </span><span class="s2">if </span><span class="s1">(i == j) 
                        </span><span class="s2">continue</span><span class="s1">; 
 
                    Method candidate = get(j); 
                    </span><span class="s2">if </span><span class="s1">(candidate == </span><span class="s2">null</span><span class="s1">) 
                        </span><span class="s2">continue</span><span class="s1">; 
 
                    </span><span class="s2">if </span><span class="s1">(!matchesNameAndDescriptor(m, candidate)) 
                        </span><span class="s2">continue</span><span class="s1">; 
 
                    </span><span class="s2">if </span><span class="s1">(hasMoreSpecificClass(m, candidate)) 
                        remove(j); 
                } 
            } 
        } 
 
        Method[] getArray() { 
            </span><span class="s2">return </span><span class="s1">methods; 
        } 
 
        </span><span class="s0">// Returns true if m1 is more specific than m2</span><span class="s1"> 
        </span><span class="s2">static boolean </span><span class="s1">hasMoreSpecificClass(Method m1, Method m2) { 
            Class&lt;?&gt; m1Class = m1.getDeclaringClass(); 
            Class&lt;?&gt; m2Class = m2.getDeclaringClass(); 
            </span><span class="s2">return </span><span class="s1">m1Class != m2Class &amp;&amp; m2Class.isAssignableFrom(m1Class); 
        } 
    } 
 
 
    </span><span class="s0">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span><span class="s1"> 
    </span><span class="s0">// be propagated to the outside world, but must instead be copied</span><span class="s1"> 
    </span><span class="s0">// via ReflectionFactory.copyMethod.</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">Method[] privateGetPublicMethods() { 
        checkInitted(); 
        Method[] res; 
        ReflectionData&lt;T&gt; rd = reflectionData(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            res = rd.publicMethods; 
            </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; 
        } 
 
        </span><span class="s0">// No cached value available; compute value recursively.</span><span class="s1"> 
        </span><span class="s0">// Start by fetching public declared methods</span><span class="s1"> 
        MethodArray methods = </span><span class="s2">new </span><span class="s1">MethodArray(); 
        { 
            Method[] tmp = privateGetDeclaredMethods(</span><span class="s2">true</span><span class="s1">); 
            methods.addAll(tmp); 
        } 
        </span><span class="s0">// Now recur over superclass and direct superinterfaces.</span><span class="s1"> 
        </span><span class="s0">// Go over superinterfaces first so we can more easily filter</span><span class="s1"> 
        </span><span class="s0">// out concrete implementations inherited from superclasses at</span><span class="s1"> 
        </span><span class="s0">// the end.</span><span class="s1"> 
        MethodArray inheritedMethods = </span><span class="s2">new </span><span class="s1">MethodArray(); 
        </span><span class="s2">for </span><span class="s1">(Class&lt;?&gt; i : getInterfaces()) { 
            inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods()); 
        } 
        </span><span class="s2">if </span><span class="s1">(!isInterface()) { 
            Class&lt;?&gt; c = getSuperclass(); 
            </span><span class="s2">if </span><span class="s1">(c != </span><span class="s2">null</span><span class="s1">) { 
                MethodArray supers = </span><span class="s2">new </span><span class="s1">MethodArray(); 
                supers.addAll(c.privateGetPublicMethods()); 
                </span><span class="s0">// Filter out concrete implementations of any</span><span class="s1"> 
                </span><span class="s0">// interface methods</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; supers.length(); i++) { 
                    Method m = supers.get(i); 
                    </span><span class="s2">if </span><span class="s1">(m != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
                            !Modifier.isAbstract(m.getModifiers()) &amp;&amp; 
                            !m.isDefault()) { 
                        inheritedMethods.removeByNameAndDescriptor(m); 
                    } 
                } 
                </span><span class="s0">// Insert superclass's inherited methods before</span><span class="s1"> 
                </span><span class="s0">// superinterfaces' to satisfy getMethod's search</span><span class="s1"> 
                </span><span class="s0">// order</span><span class="s1"> 
                supers.addAll(inheritedMethods); 
                inheritedMethods = supers; 
            } 
        } 
        </span><span class="s0">// Filter out all local methods from inherited ones</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; methods.length(); i++) { 
            Method m = methods.get(i); 
            inheritedMethods.removeByNameAndDescriptor(m); 
        } 
        methods.addAllIfNotPresent(inheritedMethods); 
        methods.removeLessSpecifics(); 
        methods.compactAndTrim(); 
        res = methods.getArray(); 
        </span><span class="s2">if </span><span class="s1">(rd != </span><span class="s2">null</span><span class="s1">) { 
            rd.publicMethods = res; 
        } 
        </span><span class="s2">return </span><span class="s1">res; 
    } 
 
 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">// Helpers for fetchers of one field, method, or constructor</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
 
    </span><span class="s2">private static </span><span class="s1">Field searchFields(Field[] fields, String name) { 
        String internedName = name.intern(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; fields.length; i++) { 
            </span><span class="s2">if </span><span class="s1">(fields[i].getName() == internedName) { 
                </span><span class="s2">return </span><span class="s1">getReflectionFactory().copyField(fields[i]); 
            } 
        } 
        </span><span class="s2">return null</span><span class="s1">; 
    } 
 
    </span><span class="s2">private </span><span class="s1">Field getField0(String name) </span><span class="s2">throws </span><span class="s1">NoSuchFieldException { 
        </span><span class="s0">// Note: the intent is that the search algorithm this routine</span><span class="s1"> 
        </span><span class="s0">// uses be equivalent to the ordering imposed by</span><span class="s1"> 
        </span><span class="s0">// privateGetPublicFields(). It fetches only the declared</span><span class="s1"> 
        </span><span class="s0">// public fields for each class, however, to reduce the number</span><span class="s1"> 
        </span><span class="s0">// of Field objects which have to be created for the common</span><span class="s1"> 
        </span><span class="s0">// case where the field being requested is declared in the</span><span class="s1"> 
        </span><span class="s0">// class which is being queried.</span><span class="s1"> 
        Field res; 
        </span><span class="s0">// Search declared public fields</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">((res = searchFields(privateGetDeclaredFields(</span><span class="s2">true</span><span class="s1">), name)) != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">res; 
        } 
        </span><span class="s0">// Direct superinterfaces, recursively</span><span class="s1"> 
        Class&lt;?&gt;[] interfaces = getInterfaces(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; interfaces.length; i++) { 
            Class&lt;?&gt; c = interfaces[i]; 
            </span><span class="s2">if </span><span class="s1">((res = c.getField0(name)) != </span><span class="s2">null</span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">res; 
            } 
        } 
        </span><span class="s0">// Direct superclass, recursively</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(!isInterface()) { 
            Class&lt;?&gt; c = getSuperclass(); 
            </span><span class="s2">if </span><span class="s1">(c != </span><span class="s2">null</span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">((res = c.getField0(name)) != </span><span class="s2">null</span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">res; 
                } 
            } 
        } 
        </span><span class="s2">return null</span><span class="s1">; 
    } 
 
    </span><span class="s2">private static </span><span class="s1">Method searchMethods(Method[] methods, 
                                        String name, 
                                        Class&lt;?&gt;[] parameterTypes) 
    { 
        Method res = </span><span class="s2">null</span><span class="s1">; 
        String internedName = name.intern(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; methods.length; i++) { 
            Method m = methods[i]; 
            </span><span class="s2">if </span><span class="s1">(m.getName() == internedName 
                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes()) 
                &amp;&amp; (res == </span><span class="s2">null</span><span class="s1"> 
                    || res.getReturnType().isAssignableFrom(m.getReturnType()))) 
                res = m; 
        } 
 
        </span><span class="s2">return </span><span class="s1">(res == </span><span class="s2">null </span><span class="s1">? res : getReflectionFactory().copyMethod(res)); 
    } 
 
    </span><span class="s2">private </span><span class="s1">Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes, </span><span class="s2">boolean </span><span class="s1">includeStaticMethods) { 
        MethodArray interfaceCandidates = </span><span class="s2">new </span><span class="s1">MethodArray(</span><span class="s5">2</span><span class="s1">); 
        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates); 
        </span><span class="s2">if </span><span class="s1">(res != </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return </span><span class="s1">res; 
 
        </span><span class="s0">// Not found on class or superclass directly</span><span class="s1"> 
        interfaceCandidates.removeLessSpecifics(); 
        </span><span class="s2">return </span><span class="s1">interfaceCandidates.getFirst(); </span><span class="s0">// may be null</span><span class="s1"> 
    } 
 
    </span><span class="s2">private </span><span class="s1">Method privateGetMethodRecursive(String name, 
            Class&lt;?&gt;[] parameterTypes, 
            </span><span class="s2">boolean </span><span class="s1">includeStaticMethods, 
            MethodArray allInterfaceCandidates) { 
        </span><span class="s0">// Note: the intent is that the search algorithm this routine</span><span class="s1"> 
        </span><span class="s0">// uses be equivalent to the ordering imposed by</span><span class="s1"> 
        </span><span class="s0">// privateGetPublicMethods(). It fetches only the declared</span><span class="s1"> 
        </span><span class="s0">// public methods for each class, however, to reduce the</span><span class="s1"> 
        </span><span class="s0">// number of Method objects which have to be created for the</span><span class="s1"> 
        </span><span class="s0">// common case where the method being requested is declared in</span><span class="s1"> 
        </span><span class="s0">// the class which is being queried.</span><span class="s1"> 
        </span><span class="s0">//</span><span class="s1"> 
        </span><span class="s0">// Due to default methods, unless a method is found on a superclass,</span><span class="s1"> 
        </span><span class="s0">// methods declared in any superinterface needs to be considered.</span><span class="s1"> 
        </span><span class="s0">// Collect all candidates declared in superinterfaces in {@code</span><span class="s1"> 
        </span><span class="s0">// allInterfaceCandidates} and select the most specific if no match on</span><span class="s1"> 
        </span><span class="s0">// a superclass is found.</span><span class="s1"> 
 
        </span><span class="s0">// Must _not_ return root methods</span><span class="s1"> 
        Method res; 
        </span><span class="s0">// Search declared public methods</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">((res = searchMethods(privateGetDeclaredMethods(</span><span class="s2">true</span><span class="s1">), 
                                 name, 
                                 parameterTypes)) != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(includeStaticMethods || !Modifier.isStatic(res.getModifiers())) 
                </span><span class="s2">return </span><span class="s1">res; 
        } 
        </span><span class="s0">// Search superclass's methods</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(!isInterface()) { 
            Class&lt;? </span><span class="s2">super </span><span class="s1">T&gt; c = getSuperclass(); 
            </span><span class="s2">if </span><span class="s1">(c != </span><span class="s2">null</span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">((res = c.getMethod0(name, parameterTypes, </span><span class="s2">true</span><span class="s1">)) != </span><span class="s2">null</span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">res; 
                } 
            } 
        } 
        </span><span class="s0">// Search superinterfaces' methods</span><span class="s1"> 
        Class&lt;?&gt;[] interfaces = getInterfaces(); 
        </span><span class="s2">for </span><span class="s1">(Class&lt;?&gt; c : interfaces) 
            </span><span class="s2">if </span><span class="s1">((res = c.getMethod0(name, parameterTypes, </span><span class="s2">false</span><span class="s1">)) != </span><span class="s2">null</span><span class="s1">) 
                allInterfaceCandidates.add(res); 
        </span><span class="s0">// Not found</span><span class="s1"> 
        </span><span class="s2">return null</span><span class="s1">; 
    } 
 
    </span><span class="s2">private </span><span class="s1">Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes, 
                                        </span><span class="s2">int </span><span class="s1">which) </span><span class="s2">throws </span><span class="s1">NoSuchMethodException 
    { 
        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC)); 
        </span><span class="s2">for </span><span class="s1">(Constructor&lt;T&gt; constructor : constructors) { 
            </span><span class="s2">if </span><span class="s1">(arrayContentsEq(parameterTypes, 
                                constructor.getParameterTypes())) { 
                </span><span class="s2">return </span><span class="s1">getReflectionFactory().copyConstructor(constructor); 
            } 
        } 
        </span><span class="s2">throw new </span><span class="s1">NoSuchMethodException(getName() + </span><span class="s6">&quot;.&lt;init&gt;&quot; </span><span class="s1">+ argumentTypesToString(parameterTypes)); 
    } 
 
    </span><span class="s0">//</span><span class="s1"> 
    </span><span class="s0">// Other helpers and base implementation</span><span class="s1"> 
    </span><span class="s0">//</span><span class="s1"> 
 
    </span><span class="s2">private static boolean </span><span class="s1">arrayContentsEq(Object[] a1, Object[] a2) { 
        </span><span class="s2">if </span><span class="s1">(a1 == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">a2 == </span><span class="s2">null </span><span class="s1">|| a2.length == </span><span class="s5">0</span><span class="s1">; 
        } 
 
        </span><span class="s2">if </span><span class="s1">(a2 == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">a1.length == </span><span class="s5">0</span><span class="s1">; 
        } 
 
        </span><span class="s2">if </span><span class="s1">(a1.length != a2.length) { 
            </span><span class="s2">return false</span><span class="s1">; 
        } 
 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; a1.length; i++) { 
            </span><span class="s2">if </span><span class="s1">(a1[i] != a2[i]) { 
                </span><span class="s2">return false</span><span class="s1">; 
            } 
        } 
 
        </span><span class="s2">return true</span><span class="s1">; 
    } 
 
    </span><span class="s2">private static </span><span class="s1">Field[] copyFields(Field[] arg) { 
        Field[] out = </span><span class="s2">new </span><span class="s1">Field[arg.length]; 
        ReflectionFactory fact = getReflectionFactory(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; arg.length; i++) { 
            out[i] = fact.copyField(arg[i]); 
        } 
        </span><span class="s2">return </span><span class="s1">out; 
    } 
 
    </span><span class="s2">private static </span><span class="s1">Method[] copyMethods(Method[] arg) { 
        Method[] out = </span><span class="s2">new </span><span class="s1">Method[arg.length]; 
        ReflectionFactory fact = getReflectionFactory(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; arg.length; i++) { 
            out[i] = fact.copyMethod(arg[i]); 
        } 
        </span><span class="s2">return </span><span class="s1">out; 
    } 
 
    </span><span class="s2">private static </span><span class="s1">&lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) { 
        Constructor&lt;U&gt;[] out = arg.clone(); 
        ReflectionFactory fact = getReflectionFactory(); 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; out.length; i++) { 
            out[i] = fact.copyConstructor(out[i]); 
        } 
        </span><span class="s2">return </span><span class="s1">out; 
    } 
 
    </span><span class="s2">private native </span><span class="s1">Field[]       getDeclaredFields0(</span><span class="s2">boolean </span><span class="s1">publicOnly); 
    </span><span class="s2">private native </span><span class="s1">Method[]      getDeclaredMethods0(</span><span class="s2">boolean </span><span class="s1">publicOnly); 
    </span><span class="s2">private native </span><span class="s1">Constructor&lt;T&gt;[] getDeclaredConstructors0(</span><span class="s2">boolean </span><span class="s1">publicOnly); 
    </span><span class="s2">private native </span><span class="s1">Class&lt;?&gt;[]   getDeclaredClasses0(); 
 
    </span><span class="s2">private static </span><span class="s1">String        argumentTypesToString(Class&lt;?&gt;[] argTypes) { 
        StringBuilder buf = </span><span class="s2">new </span><span class="s1">StringBuilder(); 
        buf.append(</span><span class="s6">&quot;(&quot;</span><span class="s1">); 
        </span><span class="s2">if </span><span class="s1">(argTypes != </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; argTypes.length; i++) { 
                </span><span class="s2">if </span><span class="s1">(i &gt; </span><span class="s5">0</span><span class="s1">) { 
                    buf.append(</span><span class="s6">&quot;, &quot;</span><span class="s1">); 
                } 
                Class&lt;?&gt; c = argTypes[i]; 
                buf.append((c == </span><span class="s2">null</span><span class="s1">) ? </span><span class="s6">&quot;null&quot; </span><span class="s1">: c.getName()); 
            } 
        } 
        buf.append(</span><span class="s6">&quot;)&quot;</span><span class="s1">); 
        </span><span class="s2">return </span><span class="s1">buf.toString(); 
    } 
 
    </span><span class="s0">/** use serialVersionUID from JDK 1.1 for interoperability */</span><span class="s1"> 
    </span><span class="s2">private static final long </span><span class="s1">serialVersionUID = </span><span class="s5">3206093459760846163L</span><span class="s1">; 
 
 
    </span><span class="s0">/** 
     * Class Class is special cased within the Serialization Stream Protocol. 
     * 
     * A Class instance is written initially into an ObjectOutputStream in the 
     * following format: 
     * </span><span class="s4">&lt;pre&gt;</span><span class="s0"> 
     *      {</span><span class="s3">@code </span><span class="s0">TC_CLASS} ClassDescriptor 
     *      A ClassDescriptor is a special cased serialization of 
     *      a {</span><span class="s3">@code </span><span class="s0">java.io.ObjectStreamClass} instance. 
     * </span><span class="s4">&lt;/pre&gt;</span><span class="s0"> 
     * A new handle is generated for the initial time the class descriptor 
     * is written into the stream. Future references to the class descriptor 
     * are written as references to the initial class descriptor instance. 
     * 
     * </span><span class="s3">@see </span><span class="s0">java.io.ObjectStreamClass 
     */</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">ObjectStreamField[] serialPersistentFields = 
        </span><span class="s2">new </span><span class="s1">ObjectStreamField[</span><span class="s5">0</span><span class="s1">]; 
 
 
    </span><span class="s0">/** 
     * Returns the assertion status that would be assigned to this 
     * class if it were to be initialized at the time this method is invoked. 
     * If this class has had its assertion status set, the most recent 
     * setting will be returned; otherwise, if any package default assertion 
     * status pertains to this class, the most recent setting for the most 
     * specific pertinent package default assertion status is returned; 
     * otherwise, if this class is not a system class (i.e., it has a 
     * class loader) its class loader's default assertion status is returned; 
     * otherwise, the system class default assertion status is returned. 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0"> 
     * Few programmers will have any need for this method; it is provided 
     * for the benefit of the JRE itself.  (It allows a class to determine at 
     * the time that it is initialized whether assertions should be enabled.) 
     * Note that this method is not guaranteed to return the actual 
     * assertion status that was (or will be) associated with the specified 
     * class when it was (or will be) initialized. 
     * 
     * </span><span class="s3">@return </span><span class="s0">the desired assertion status of the specified class. 
     * </span><span class="s3">@see    </span><span class="s0">java.lang.ClassLoader#setClassAssertionStatus 
     * </span><span class="s3">@see    </span><span class="s0">java.lang.ClassLoader#setPackageAssertionStatus 
     * </span><span class="s3">@see    </span><span class="s0">java.lang.ClassLoader#setDefaultAssertionStatus 
     * </span><span class="s3">@since  </span><span class="s0">1.4 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">desiredAssertionStatus() { 
        ClassLoader loader = getClassLoader(); 
        </span><span class="s0">// If the loader is null this is a system class, so ask the VM</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(loader == </span><span class="s2">null</span><span class="s1">) 
            </span><span class="s2">return </span><span class="s1">desiredAssertionStatus0(</span><span class="s2">this</span><span class="s1">); 
 
        </span><span class="s0">// If the classloader has been initialized with the assertion</span><span class="s1"> 
        </span><span class="s0">// directives, ask it. Otherwise, ask the VM.</span><span class="s1"> 
        </span><span class="s2">synchronized</span><span class="s1">(loader.assertionLock) { 
            </span><span class="s2">if </span><span class="s1">(loader.classAssertionStatus != </span><span class="s2">null</span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">loader.desiredAssertionStatus(getName()); 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">desiredAssertionStatus0(</span><span class="s2">this</span><span class="s1">); 
    } 
 
    </span><span class="s0">// Retrieves the desired assertion status of this class from the VM</span><span class="s1"> 
    </span><span class="s2">private static native boolean </span><span class="s1">desiredAssertionStatus0(Class&lt;?&gt; clazz); 
 
    </span><span class="s0">/** 
     * Returns true if and only if this class was declared as an enum in the 
     * source code. 
     * 
     * </span><span class="s3">@return </span><span class="s0">true if and only if this class was declared as an enum in the 
     *     source code 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public boolean </span><span class="s1">isEnum() { 
        </span><span class="s0">// An enum must both directly extend java.lang.Enum and have</span><span class="s1"> 
        </span><span class="s0">// the ENUM bit set; classes for specialized enum constants</span><span class="s1"> 
        </span><span class="s0">// don't do the former.</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getModifiers() &amp; ENUM) != </span><span class="s5">0 </span><span class="s1">&amp;&amp; 
        </span><span class="s2">this</span><span class="s1">.getSuperclass() == java.lang.Enum.</span><span class="s2">class</span><span class="s1">; 
    } 
 
    </span><span class="s0">// Fetches the factory for reflective objects</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">ReflectionFactory getReflectionFactory() { 
        </span><span class="s2">if </span><span class="s1">(reflectionFactory == </span><span class="s2">null</span><span class="s1">) { 
            reflectionFactory = 
                java.security.AccessController.doPrivileged 
                    (</span><span class="s2">new </span><span class="s1">sun.reflect.ReflectionFactory.GetReflectionFactoryAction()); 
        } 
        </span><span class="s2">return </span><span class="s1">reflectionFactory; 
    } 
    </span><span class="s2">private static </span><span class="s1">ReflectionFactory reflectionFactory; 
 
    </span><span class="s0">// To be able to query system properties as soon as they're available</span><span class="s1"> 
    </span><span class="s2">private static boolean </span><span class="s1">initted = </span><span class="s2">false</span><span class="s1">; 
    </span><span class="s2">private static void </span><span class="s1">checkInitted() { 
        </span><span class="s2">if </span><span class="s1">(initted) </span><span class="s2">return</span><span class="s1">; 
        AccessController.doPrivileged(</span><span class="s2">new </span><span class="s1">PrivilegedAction&lt;Void&gt;() { 
                </span><span class="s2">public </span><span class="s1">Void run() { 
                    </span><span class="s0">// Tests to ensure the system properties table is fully</span><span class="s1"> 
                    </span><span class="s0">// initialized. This is needed because reflection code is</span><span class="s1"> 
                    </span><span class="s0">// called very early in the initialization process (before</span><span class="s1"> 
                    </span><span class="s0">// command-line arguments have been parsed and therefore</span><span class="s1"> 
                    </span><span class="s0">// these user-settable properties installed.) We assume that</span><span class="s1"> 
                    </span><span class="s0">// if System.out is non-null then the System class has been</span><span class="s1"> 
                    </span><span class="s0">// fully initialized and that the bulk of the startup code</span><span class="s1"> 
                    </span><span class="s0">// has been run.</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">(System.out == </span><span class="s2">null</span><span class="s1">) { 
                        </span><span class="s0">// java.lang.System not yet fully initialized</span><span class="s1"> 
                        </span><span class="s2">return null</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// Doesn't use Boolean.getBoolean to avoid class init.</span><span class="s1"> 
                    String val = 
                        System.getProperty(</span><span class="s6">&quot;sun.reflect.noCaches&quot;</span><span class="s1">); 
                    </span><span class="s2">if </span><span class="s1">(val != </span><span class="s2">null </span><span class="s1">&amp;&amp; val.equals(</span><span class="s6">&quot;true&quot;</span><span class="s1">)) { 
                        useCaches = </span><span class="s2">false</span><span class="s1">; 
                    } 
 
                    initted = </span><span class="s2">true</span><span class="s1">; 
                    </span><span class="s2">return null</span><span class="s1">; 
                } 
            }); 
    } 
 
    </span><span class="s0">/** 
     * Returns the elements of this enum class or null if this 
     * Class object does not represent an enum type. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an array containing the values comprising the enum class 
     *     represented by this Class object in the order they're 
     *     declared, or null if this Class object does not 
     *     represent an enum type 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">T[] getEnumConstants() { 
        T[] values = getEnumConstantsShared(); 
        </span><span class="s2">return </span><span class="s1">(values != </span><span class="s2">null</span><span class="s1">) ? values.clone() : </span><span class="s2">null</span><span class="s1">; 
    } 
 
    </span><span class="s0">/** 
     * Returns the elements of this enum class or null if this 
     * Class object does not represent an enum type; 
     * identical to getEnumConstants except that the result is 
     * uncloned, cached, and shared by all callers. 
     */</span><span class="s1"> 
    T[] getEnumConstantsShared() { 
        </span><span class="s2">if </span><span class="s1">(enumConstants == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(!isEnum()) </span><span class="s2">return null</span><span class="s1">; 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s2">final </span><span class="s1">Method values = getMethod(</span><span class="s6">&quot;values&quot;</span><span class="s1">); 
                java.security.AccessController.doPrivileged( 
                    </span><span class="s2">new </span><span class="s1">java.security.PrivilegedAction&lt;Void&gt;() { 
                        </span><span class="s2">public </span><span class="s1">Void run() { 
                                values.setAccessible(</span><span class="s2">true</span><span class="s1">); 
                                </span><span class="s2">return null</span><span class="s1">; 
                            } 
                        }); 
                @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
                T[] temporaryConstants = (T[])values.invoke(</span><span class="s2">null</span><span class="s1">); 
                enumConstants = temporaryConstants; 
            } 
            </span><span class="s0">// These can happen when users concoct enum-like classes</span><span class="s1"> 
            </span><span class="s0">// that don't comply with the enum spec.</span><span class="s1"> 
            </span><span class="s2">catch </span><span class="s1">(InvocationTargetException | NoSuchMethodException | 
                   IllegalAccessException ex) { </span><span class="s2">return null</span><span class="s1">; } 
        } 
        </span><span class="s2">return </span><span class="s1">enumConstants; 
    } 
    </span><span class="s2">private volatile transient </span><span class="s1">T[] enumConstants = </span><span class="s2">null</span><span class="s1">; 
 
    </span><span class="s0">/** 
     * Returns a map from simple name to enum constant.  This package-private 
     * method is used internally by Enum to implement 
     * {</span><span class="s3">@code </span><span class="s0">public static </span><span class="s4">&lt;T extends Enum&lt;T&gt;</span><span class="s0">&gt; T valueOf(Class</span><span class="s4">&lt;T&gt;</span><span class="s0">, String)} 
     * efficiently.  Note that the map is returned by this method is 
     * created lazily on first use.  Typically it won't ever get created. 
     */</span><span class="s1"> 
    Map&lt;String, T&gt; enumConstantDirectory() { 
        </span><span class="s2">if </span><span class="s1">(enumConstantDirectory == </span><span class="s2">null</span><span class="s1">) { 
            T[] universe = getEnumConstantsShared(); 
            </span><span class="s2">if </span><span class="s1">(universe == </span><span class="s2">null</span><span class="s1">) 
                </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException( 
                    getName() + </span><span class="s6">&quot; is not an enum type&quot;</span><span class="s1">); 
            Map&lt;String, T&gt; m = </span><span class="s2">new </span><span class="s1">HashMap&lt;&gt;(</span><span class="s5">2 </span><span class="s1">* universe.length); 
            </span><span class="s2">for </span><span class="s1">(T constant : universe) 
                m.put(((Enum&lt;?&gt;)constant).name(), constant); 
            enumConstantDirectory = m; 
        } 
        </span><span class="s2">return </span><span class="s1">enumConstantDirectory; 
    } 
    </span><span class="s2">private volatile transient </span><span class="s1">Map&lt;String, T&gt; enumConstantDirectory = </span><span class="s2">null</span><span class="s1">; 
 
    </span><span class="s0">/** 
     * Casts an object to the class or interface represented 
     * by this {</span><span class="s3">@code </span><span class="s0">Class} object. 
     * 
     * </span><span class="s3">@param </span><span class="s0">obj the object to be cast 
     * </span><span class="s3">@return </span><span class="s0">the object after casting, or null if obj is null 
     * 
     * </span><span class="s3">@throws </span><span class="s0">ClassCastException if the object is not 
     * null and is not assignable to the type T. 
     * 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
    </span><span class="s2">public </span><span class="s1">T cast(Object obj) { 
        </span><span class="s2">if </span><span class="s1">(obj != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isInstance(obj)) 
            </span><span class="s2">throw new </span><span class="s1">ClassCastException(cannotCastMsg(obj)); 
        </span><span class="s2">return </span><span class="s1">(T) obj; 
    } 
 
    </span><span class="s2">private </span><span class="s1">String cannotCastMsg(Object obj) { 
        </span><span class="s2">return </span><span class="s6">&quot;Cannot cast &quot; </span><span class="s1">+ obj.getClass().getName() + </span><span class="s6">&quot; to &quot; </span><span class="s1">+ getName(); 
    } 
 
    </span><span class="s0">/** 
     * Casts this {</span><span class="s3">@code </span><span class="s0">Class} object to represent a subclass of the class 
     * represented by the specified class object.  Checks that the cast 
     * is valid, and throws a {</span><span class="s3">@code </span><span class="s0">ClassCastException} if it is not.  If 
     * this method succeeds, it always returns a reference to this class object. 
     * 
     * </span><span class="s4">&lt;p&gt;</span><span class="s0">This method is useful when a client needs to &quot;narrow&quot; the type of 
     * a {</span><span class="s3">@code </span><span class="s0">Class} object to pass it to an API that restricts the 
     * {</span><span class="s3">@code </span><span class="s0">Class} objects that it is willing to accept.  A cast would 
     * generate a compile-time warning, as the correctness of the cast 
     * could not be checked at runtime (because generic types are implemented 
     * by erasure). 
     * 
     * </span><span class="s3">@param </span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt; </span><span class="s0">the type to cast this class object to 
     * </span><span class="s3">@param </span><span class="s0">clazz the class of the type to cast this class object to 
     * </span><span class="s3">@return </span><span class="s0">this {</span><span class="s3">@code </span><span class="s0">Class} object, cast to represent a subclass of 
     *    the specified class object. 
     * </span><span class="s3">@throws </span><span class="s0">ClassCastException if this {</span><span class="s3">@code </span><span class="s0">Class} object does not 
     *    represent a subclass of the specified class (here &quot;subclass&quot; includes 
     *    the class itself). 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
    </span><span class="s2">public </span><span class="s1">&lt;U&gt; Class&lt;? </span><span class="s2">extends </span><span class="s1">U&gt; asSubclass(Class&lt;U&gt; clazz) { 
        </span><span class="s2">if </span><span class="s1">(clazz.isAssignableFrom(</span><span class="s2">this</span><span class="s1">)) 
            </span><span class="s2">return </span><span class="s1">(Class&lt;? </span><span class="s2">extends </span><span class="s1">U&gt;) </span><span class="s2">this</span><span class="s1">; 
        </span><span class="s2">else</span><span class="s1"> 
            </span><span class="s2">throw new </span><span class="s1">ClassCastException(</span><span class="s2">this</span><span class="s1">.toString()); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
    </span><span class="s2">public </span><span class="s1">&lt;A </span><span class="s2">extends </span><span class="s1">Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) { 
        Objects.requireNonNull(annotationClass); 
 
        </span><span class="s2">return </span><span class="s1">(A) annotationData().annotations.get(annotationClass); 
    } 
 
    </span><span class="s0">/** 
     * {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    @Override 
    </span><span class="s2">public boolean </span><span class="s1">isAnnotationPresent(Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt; annotationClass) { 
        </span><span class="s2">return </span><span class="s1">GenericDeclaration.</span><span class="s2">super</span><span class="s1">.isAnnotationPresent(annotationClass); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    @Override 
    </span><span class="s2">public </span><span class="s1">&lt;A </span><span class="s2">extends </span><span class="s1">Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) { 
        Objects.requireNonNull(annotationClass); 
 
        AnnotationData annotationData = annotationData(); 
        </span><span class="s2">return </span><span class="s1">AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations, 
                                                          </span><span class="s2">this</span><span class="s1">, 
                                                          annotationClass); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Annotation[] getAnnotations() { 
        </span><span class="s2">return </span><span class="s1">AnnotationParser.toArray(annotationData().annotations); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    @Override 
    @SuppressWarnings(</span><span class="s6">&quot;unchecked&quot;</span><span class="s1">) 
    </span><span class="s2">public </span><span class="s1">&lt;A </span><span class="s2">extends </span><span class="s1">Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) { 
        Objects.requireNonNull(annotationClass); 
 
        </span><span class="s2">return </span><span class="s1">(A) annotationData().declaredAnnotations.get(annotationClass); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@throws </span><span class="s0">NullPointerException {</span><span class="s3">@inheritDoc</span><span class="s0">} 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    @Override 
    </span><span class="s2">public </span><span class="s1">&lt;A </span><span class="s2">extends </span><span class="s1">Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) { 
        Objects.requireNonNull(annotationClass); 
 
        </span><span class="s2">return </span><span class="s1">AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations, 
                                                                 annotationClass); 
    } 
 
    </span><span class="s0">/** 
     * </span><span class="s3">@since </span><span class="s0">1.5 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">Annotation[] getDeclaredAnnotations()  { 
        </span><span class="s2">return </span><span class="s1">AnnotationParser.toArray(annotationData().declaredAnnotations); 
    } 
 
    </span><span class="s0">// annotation data that might get invalidated when JVM TI RedefineClasses() is called</span><span class="s1"> 
    </span><span class="s2">private static class </span><span class="s1">AnnotationData { 
        </span><span class="s2">final </span><span class="s1">Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; annotations; 
        </span><span class="s2">final </span><span class="s1">Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; declaredAnnotations; 
 
        </span><span class="s0">// Value of classRedefinedCount when we created this AnnotationData instance</span><span class="s1"> 
        </span><span class="s2">final int </span><span class="s1">redefinedCount; 
 
        AnnotationData(Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; annotations, 
                       Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; declaredAnnotations, 
                       </span><span class="s2">int </span><span class="s1">redefinedCount) { 
            </span><span class="s2">this</span><span class="s1">.annotations = annotations; 
            </span><span class="s2">this</span><span class="s1">.declaredAnnotations = declaredAnnotations; 
            </span><span class="s2">this</span><span class="s1">.redefinedCount = redefinedCount; 
        } 
    } 
 
    </span><span class="s0">// Annotations cache</span><span class="s1"> 
    @SuppressWarnings(</span><span class="s6">&quot;UnusedDeclaration&quot;</span><span class="s1">) 
    </span><span class="s2">private volatile transient </span><span class="s1">AnnotationData annotationData; 
 
    </span><span class="s2">private </span><span class="s1">AnnotationData annotationData() { 
        </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) { </span><span class="s0">// retry loop</span><span class="s1"> 
            AnnotationData annotationData = </span><span class="s2">this</span><span class="s1">.annotationData; 
            </span><span class="s2">int </span><span class="s1">classRedefinedCount = </span><span class="s2">this</span><span class="s1">.classRedefinedCount; 
            </span><span class="s2">if </span><span class="s1">(annotationData != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
                annotationData.redefinedCount == classRedefinedCount) { 
                </span><span class="s2">return </span><span class="s1">annotationData; 
            } 
            </span><span class="s0">// null or stale annotationData -&gt; optimistically create new instance</span><span class="s1"> 
            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount); 
            </span><span class="s0">// try to install it</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">(Atomic.casAnnotationData(</span><span class="s2">this</span><span class="s1">, annotationData, newAnnotationData)) { 
                </span><span class="s0">// successfully installed new AnnotationData</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">newAnnotationData; 
            } 
        } 
    } 
 
    </span><span class="s2">private </span><span class="s1">AnnotationData createAnnotationData(</span><span class="s2">int </span><span class="s1">classRedefinedCount) { 
        Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; declaredAnnotations = 
            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), </span><span class="s2">this</span><span class="s1">); 
        Class&lt;?&gt; superClass = getSuperclass(); 
        Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; annotations = </span><span class="s2">null</span><span class="s1">; 
        </span><span class="s2">if </span><span class="s1">(superClass != </span><span class="s2">null</span><span class="s1">) { 
            Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; superAnnotations = 
                superClass.annotationData().annotations; 
            </span><span class="s2">for </span><span class="s1">(Map.Entry&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) { 
                Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt; annotationClass = e.getKey(); 
                </span><span class="s2">if </span><span class="s1">(AnnotationType.getInstance(annotationClass).isInherited()) { 
                    </span><span class="s2">if </span><span class="s1">(annotations == </span><span class="s2">null</span><span class="s1">) { </span><span class="s0">// lazy construction</span><span class="s1"> 
                        annotations = </span><span class="s2">new </span><span class="s1">LinkedHashMap&lt;&gt;((Math.max( 
                                declaredAnnotations.size(), 
                                Math.min(</span><span class="s5">12</span><span class="s1">, declaredAnnotations.size() + superAnnotations.size()) 
                            ) * </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">3</span><span class="s1"> 
                        ); 
                    } 
                    annotations.put(annotationClass, e.getValue()); 
                } 
            } 
        } 
        </span><span class="s2">if </span><span class="s1">(annotations == </span><span class="s2">null</span><span class="s1">) { 
            </span><span class="s0">// no inherited annotations -&gt; share the Map with declaredAnnotations</span><span class="s1"> 
            annotations = declaredAnnotations; 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// at least one inherited annotation -&gt; declared may override inherited</span><span class="s1"> 
            annotations.putAll(declaredAnnotations); 
        } 
        </span><span class="s2">return new </span><span class="s1">AnnotationData(annotations, declaredAnnotations, classRedefinedCount); 
    } 
 
    </span><span class="s0">// Annotation types cache their internal (AnnotationType) form</span><span class="s1"> 
 
    @SuppressWarnings(</span><span class="s6">&quot;UnusedDeclaration&quot;</span><span class="s1">) 
    </span><span class="s2">private volatile transient </span><span class="s1">AnnotationType annotationType; 
 
    </span><span class="s2">boolean </span><span class="s1">casAnnotationType(AnnotationType oldType, AnnotationType newType) { 
        </span><span class="s2">return </span><span class="s1">Atomic.casAnnotationType(</span><span class="s2">this</span><span class="s1">, oldType, newType); 
    } 
 
    AnnotationType getAnnotationType() { 
        </span><span class="s2">return </span><span class="s1">annotationType; 
    } 
 
    Map&lt;Class&lt;? </span><span class="s2">extends </span><span class="s1">Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() { 
        </span><span class="s2">return </span><span class="s1">annotationData().declaredAnnotations; 
    } 
 
    </span><span class="s0">/* Backing store of user-defined values pertaining to this class. 
     * Maintained by the ClassValue class. 
     */</span><span class="s1"> 
    </span><span class="s2">transient </span><span class="s1">ClassValue.ClassValueMap classValueMap; 
 
    </span><span class="s0">/** 
     * Returns an {</span><span class="s3">@code </span><span class="s0">AnnotatedType} object that represents the use of a 
     * type to specify the superclass of the entity represented by this {</span><span class="s3">@code</span><span class="s0"> 
     * Class} object. (The </span><span class="s4">&lt;em&gt;</span><span class="s0">use</span><span class="s4">&lt;/em&gt; </span><span class="s0">of type Foo to specify the superclass 
     * in '...  extends Foo' is distinct from the </span><span class="s4">&lt;em&gt;</span><span class="s0">declaration</span><span class="s4">&lt;/em&gt; </span><span class="s0">of type 
     * Foo.) 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a type whose declaration 
     * does not explicitly indicate an annotated superclass, then the return 
     * value is an {</span><span class="s3">@code </span><span class="s0">AnnotatedType} object representing an element with no 
     * annotations. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} represents either the {</span><span class="s3">@code </span><span class="s0">Object} class, an 
     * interface type, an array type, a primitive type, or void, the return 
     * value is {</span><span class="s3">@code </span><span class="s0">null}. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an object representing the superclass 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">AnnotatedType getAnnotatedSuperclass() { 
        </span><span class="s2">if </span><span class="s1">(</span><span class="s2">this </span><span class="s1">== Object.</span><span class="s2">class </span><span class="s1">|| 
                isInterface() || 
                isArray() || 
                isPrimitive() || 
                </span><span class="s2">this </span><span class="s1">== Void.TYPE) { 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
 
        </span><span class="s2">return </span><span class="s1">TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), </span><span class="s2">this</span><span class="s1">); 
    } 
 
    </span><span class="s0">/** 
     * Returns an array of {</span><span class="s3">@code </span><span class="s0">AnnotatedType} objects that represent the use 
     * of types to specify superinterfaces of the entity represented by this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. (The </span><span class="s4">&lt;em&gt;</span><span class="s0">use</span><span class="s4">&lt;/em&gt; </span><span class="s0">of type Foo to specify a 
     * superinterface in '... implements Foo' is distinct from the 
     * </span><span class="s4">&lt;em&gt;</span><span class="s0">declaration</span><span class="s4">&lt;/em&gt; </span><span class="s0">of type Foo.) 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class, the return value is 
     * an array containing objects representing the uses of interface types to 
     * specify interfaces implemented by the class. The order of the objects in 
     * the array corresponds to the order of the interface types used in the 
     * 'implements' clause of the declaration of this {</span><span class="s3">@code </span><span class="s0">Class} object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents an interface, the return 
     * value is an array containing objects representing the uses of interface 
     * types to specify interfaces directly extended by the interface. The 
     * order of the objects in the array corresponds to the order of the 
     * interface types used in the 'extends' clause of the declaration of this 
     * {</span><span class="s3">@code </span><span class="s0">Class} object. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents a class or interface whose 
     * declaration does not explicitly indicate any annotated superinterfaces, 
     * the return value is an array of length 0. 
     * 
     * </span><span class="s4">&lt;p&gt; </span><span class="s0">If this {</span><span class="s3">@code </span><span class="s0">Class} object represents either the {</span><span class="s3">@code </span><span class="s0">Object} 
     * class, an array type, a primitive type, or void, the return value is an 
     * array of length 0. 
     * 
     * </span><span class="s3">@return </span><span class="s0">an array representing the superinterfaces 
     * </span><span class="s3">@since </span><span class="s0">1.8 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">AnnotatedType[] getAnnotatedInterfaces() { 
         </span><span class="s2">return </span><span class="s1">TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), </span><span class="s2">this</span><span class="s1">); 
    } 
} 
</span></pre>
</body>
</html>